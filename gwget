#!/usr/bin/env python2.7

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import re
import threading
import time
import functools
import urllib
import urlparse
import pickle
try:
	import xattr
except ImportError:
	xattr = None
import dbus
import dbus.service
import dbus.glib

PROGNAME = 'gwget'
APPNAME = 'hu.uucp.gwget'


def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def display_error(e):
	if threading.currentThread().name != 'MainThread':
		gtk.threads_enter()
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = '%s (#%d)\n%s' % (e.strerror, e.errno, e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()
	if threading.currentThread().name != 'MainThread':
		gtk.threads_leave()

class DialogCancel(Exception):
	pass

def question(msg, yes=None, parent=None, cancelable=False, default=gtk.RESPONSE_YES):
	dlg = gtk.MessageDialog(parent, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_NONE)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if yes is None:
		dlg.add_buttons(gtk.STOCK_YES, gtk.RESPONSE_YES)
	else:
		if type(yes) in [type(()), type([])]:
			btn_yes = StockButton(label=yes[0], stock=yes[1])
			dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
			btn_yes.show()
		else:
			dlg.add_buttons(yes, gtk.RESPONSE_YES)
	dlg.add_buttons(gtk.STOCK_NO, gtk.RESPONSE_NO)
	if cancelable:
		dlg.add_buttons(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		add_key_binding(dlg, 'Escape', lambda a,b,c,d: dlg.response(gtk.RESPONSE_CANCEL) or True)
	dlg.set_default_response(default)
	resp = dlg.run()
	dlg.destroy()
	if resp == gtk.RESPONSE_CANCEL:
		raise DialogCancel()
	return (resp == gtk.RESPONSE_YES)

def set_dialog_icon_name(dlg, icon):
	img = dlg.get_content_area().children()[0].children()[0]
	img.set_from_icon_name(icon, gtk.ICON_SIZE_DIALOG)

def create_choose_dialog(action, path=None, init=None):
	btn_accept_stock = gtk.STOCK_OPEN
	if action in [gtk.FILE_CHOOSER_ACTION_SAVE, gtk.FILE_CHOOSER_ACTION_CREATE_FOLDER]:
		btn_accept_stock = gtk.STOCK_SAVE
	dlg = gtk.FileChooserDialog(parent=None, action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	
	if action in [gtk.FILE_CHOOSER_ACTION_OPEN, gtk.FILE_CHOOSER_ACTION_SAVE] and path is not None:
		dlg.set_filename(path)
	else:
		dlg.set_current_folder(path or LastFolder)
	if init is not None:
		dlg.set_current_name(init)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	return dlg

def choose_dialog(action, path=None, init=None):
	selected = None
	dlg = create_choose_dialog(action, path=path, init=init)
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			# 'Working Dir' button
			dlg.set_current_folder(os.getcwd())
		else:
			break
	global LastFolder
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None, init=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename=filename, init=init)

def choose_folder(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, folder=folder)

def choose_open_file(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN, folder=folder)

class FileChooserEntry(gtk.HBox):
	def __init__(self, label='', path='', action=gtk.FILE_CHOOSER_ACTION_OPEN):
		super(self.__class__, self).__init__(spacing=2)
		self.Label = gtk.Label(label)
		self.Label.set_alignment(0, 0)
		self.Label.set_padding(2, 8)
		self.Entry = gtk.Entry()
		self.Entry.set_text(path)
		self.Button = StockButton(label='', stock=gtk.STOCK_OPEN, icon_size=gtk.ICON_SIZE_MENU)
		self.Button.connect('clicked', self.choose, action)
		self.pack_start(self.Label, 0, 0)
		self.pack_start(self.Entry, 1, 1)
		self.pack_start(self.Button, 0, 0)
	def get_text(self):
		return self.Entry.get_text()
	def set_text(self, text):
		return self.Entry.set_text(text)
	def get_label(self):
		return self.Label.get_text()
	def set_label(self, text):
		return self.Label.set_text(text)
	def choose(self, btn, action):
		p = choose_dialog(action, path=self.Entry.get_text())
		if p is not None:
			self.set_text(p)

class ScrolledTextView(gtk.ScrolledWindow):
	def __init__(self):
		super(self.__class__, self).__init__()
		self.TextView = gtk.TextView()
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.set_shadow_type(gtk.SHADOW_IN)
		self.add(self.TextView)
		self.TextView.set_editable(True)
		self.TextView.set_accepts_tab(False)
		self.TextView.set_wrap_mode(gtk.WRAP_NONE)
		self.TextView.modify_font(pango.FontDescription('monospace'))
		for attr, val in gtk.TextView.__dict__.iteritems():
			# make TextView class methods inherited
			if not attr.startswith('_') and not hasattr(self, attr) and callable(val):
				self.__dict__[attr] = functools.partial(val, self.TextView)
	def get_text(self):
		bufr = self.TextView.get_buffer()
		return bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True)
	def set_text(self, text):
		bufr = self.TextView.get_buffer()
		return bufr.set_text(text)
	def grab_focus(self):
		return self.TextView.grab_focus()

class LabelledEntry(gtk.HBox):
	def __init__(self, label='', markup=None, tooltip=None, spacing=2):
		super(self.__class__, self).__init__(spacing=spacing)
		self.Label = gtk.Label(label)
		self.Entry = gtk.Entry()
		self.Label.set_alignment(0, 0)
		self.Label.set_padding(4, 5)
		if markup is not None:
			self.Label.set_markup(markup)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
		self.pack_start(self.Label, 0, 1)
		self.pack_start(self.Entry, 1, 1)
		for cname in 'Entry', 'Label':
			for attr, val in getattr(gtk, cname).__dict__.iteritems():
				if not attr.startswith('_') and not hasattr(self, attr) and callable(val):
					self.__dict__[attr] = functools.partial(val, getattr(self, cname))


def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None, tooltip=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_markup(self, markup):
		x, lbl = self.__get_children()
		lbl.set_markup(markup)

class StockMenuItem(gtk.ImageMenuItem):
	def __init__(self, label=None, stock_id=None, accel_group=None):
		gtk.ImageMenuItem.__init__(self, stock_id, accel_group)
		if label is not None:
			self.set_label(label)

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left in toolitems:
		hid = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(_(tip))
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		else:
			Lstocklabel = None
			st = gtk.stock_lookup(stock)
			if st:
				Lstocklabel = re.sub('_', '', st[1])
			if label is not None:
				Llabel = _(label)
			else:
				Llabel = Lstocklabel
			if tip is not None:
				Ltip = _(tip)
			else:
				if label is not None:
					Ltip = Llabel
				else:
					Ltip = Lstocklabel
			tbi = StockToolButton(label=Llabel, stock=stock, tooltip=Ltip)
			tbi.set_data('stock', stock)
			tbi.set_data('label', label)
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

def str_accurate_at_time(ts):
	then = time.localtime(ts)
	now = time.localtime(time.time())
	if now.tm_year == then.tm_year:
		if now.tm_mon == then.tm_mon:
			if now.tm_mday == then.tm_mday:
				fmt = '%H:%M'
			else:
				fmt = '%b. %d'
		else:
			fmt = '%b. %d'
	else:
		fmt = '%Y %b.'
	return time.strftime(fmt, then)

## OS functions

def mkdir(d):
	p = os.path.dirname(d)
	if not os.path.exists(p):
		mkdir(p)
	try:
		os.mkdir(d)
	except OSError, e:
		if e.errno != os.errno.EEXIST:
			raise e

def stderr(s):
	sys.stderr.write(s)

def delete(f, warn=True):
	try:
		os.unlink(f)
	except OSError, e:
		if warn:
			stderr('%s: error %d: %s\n' % (e.filename, e.errno, e.strerror))
		if e.errno != os.errno.ENOENT:
			display_error(e)
			return False
	return True

def run_detached(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			try:
				os.execvp(cmd, args)
			except OSError:
				pass
			os._exit(127)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

class Readlines(object):
	def __init__(self, handle):
		self.handle = handle
	def __iter__(self):
		return self
	def next(self):
		s = self.handle.readline()
		if s == '':
			raise StopIteration
		return s
	def __del__(self):
		pass

def convert_to_bytes(s, p='b'):
	prefix = {'b': 1, 'k': 1024, 'm': 1024**2, 'g': 1024**3, 't': 1024**4, 'p': 1024**5,}
	m = re.search('(.+?)([a-z]?)$', s, re.IGNORECASE)
	b = float(m.group(1)) * prefix[m.group(2).lower() or 'b']
	return b / prefix[p]

def set_xattrs_file(filename, attrs):
	fh = open(filename, 'r')
	try:
		set_xattrs(fh, attrs, filename)
	except:
		raise
	finally:
		fh.close()

def set_xattrs(fh, attrs, filename='-'):
	if xattr is not None:
		for attrname, attrval in attrs.iteritems():
			try:
				if attrval is None:
					try:
						xattr.removexattr(fh, attrname)
					except IOError, e:
						if e.errno != os.errno.ENODATA:
							raise e
				else:
					xattr.setxattr(fh, attrname, attrval)
			except IOError, e:
				stderr(_("Notice: can not set xattr '%s' on '%s': %s\n") % (attrname, filename, str(e)))

### Private methods ###

class Download(object):
	def __init__(self, url, params={}):
		self.added_ts = time.time()
		self.original_url = url
		self.actual_url = url
		self.params = params
		self.progress_type = 'bar:force'
		#self.progress_type = 'dot:default'
		self.logfile = next_logfile()
		self.outfile = None
		self.Lock = threading.Lock()
		self._pid = None
		self.init()
	def morior(self):
		delattr(self, 'Lock')
	def resurgo(self):
		self.Lock = threading.Lock()
		if self.running:
			t2 = threading.Thread(target=self.watch_log, args=())
			t2.daemon = True
			t2.start()
	def configure(self, attrs, items):
		for k, v in attrs.iteritems():
			setattr(self, k, v)
	def init(self):
		self['status'] = S_QUEUE
		self.completed = False
		self.running = False
		self.size = None
		self.percent = -1
		self.speed = 0
		self.speed_str = ''
		self.eta = -1
		self.eta_str = ''
		self.lastline = ''
	def __getitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			self.Lock.release()
			return getattr(self, '_' + key)
		else:
			raise KeyError()
	def __setitem__(self, key, val):
		self.Lock.acquire(True)
		if key == 'status' and hasattr(self, '_status'):
			if (self._status == S_STOP and val == S_DL) or (self._status in [S_SAVED, S_STOP] and val == S_ERR):
				# Do not change status S_STOP -> S_DL ; S_SAVED -> S_ERR ; S_STOP -> S_ERR ;
				self.Lock.release()
				return False
			if self._status == S_INIT and val == S_DL:
				# Set xAttributes when just started to download
				setxattributes(self)
		setattr(self, '_' + key, val)
		self.Lock.release()
		return True
	def __delitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			delattr(self, '_' + key)
		self.Lock.release()
	def spawn_wget(self, args=[]):
		reader, writer = os.pipe()
		pid = os.fork()
		if pid == 0:
			os.putenv('LANG', 'C')
			if self.params.has_key('proxy_url'):
				proxy = self.params['proxy_url']
				os.putenv('http_proxy', proxy)
				os.putenv('https_proxy', proxy)
				os.putenv('ftp_proxy', proxy)
			os.close(reader)
			os.dup2(writer, sys.stdout.fileno())
			os.dup2(writer, sys.stderr.fileno())
			sys.stdin.close()
			os.closerange(3, 255)
			os.execvp('wget', ['wget'] + args)
			os._exit(127)
		os.close(writer)
		return os.fdopen(reader, 'r')
	def start(self):
		if self['pid'] is not None:
			return
		self.init()
		refresh_download_state(self)
		if not delete(self.logfile, warn=False):
			return
		
		wget_args = []
		for k, v in self.params.iteritems():
			if k.startswith('-'):
				if hasattr(v, '__iter__'):
					for v1 in v:
						wget_args.append(k)
						wget_args.append(v1)
				else:
					if k.startswith('--') and v is False:
						k = '--no-' + k[2:]
					wget_args.append(k)
					if v is not True and v is not False and v is not None:
						wget_args.append(v)
			elif k == '':
				# append custom options
				for v1 in v:
					wget_args.append(v1)
		wget_args += ['--verbose', '--output-file', self.logfile, \
		  '--background', '--continue', '--progress', self.progress_type, \
		  '--adjust-extension', '--content-disposition', '--retry-connrefused', \
		  '--auth-no-challenge']
		wget_args.append(self.original_url)
		try:
			readhandle = self.spawn_wget(wget_args)
		except OSError, e:
			display_error(e)
			return
		
		self['status'] = S_INIT
		refresh_download_state(self)
		t1 = threading.Thread(target=self.watch_output, args=(readhandle,))
		t1.daemon = True
		t1.start()
	def wget_running(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], 0)
				return True
			except OSError:
				pass
		return False
	def watch_output(self, readhandle):
		for line in Readlines(readhandle):
			stderr(line)
			line = line.strip()
			if line != '':
				self.lastline = line
				m_pid = re.search('pid (\d+)', line)
				if m_pid:
					self['pid'] = int(m_pid.group(1))
				refresh_download_state(self)
		readhandle.close()
		if self['pid']:
			self.running = True
			t2 = threading.Thread(target=self.watch_log, args=())
			t2.daemon = True
			t2.start()
		else:
			self['status'] = S_ERR
		refresh_download_state(self)
	def watch_log(self):
		while not os.path.exists(self.logfile):
			time.sleep(1)
		fh = open(self.logfile, 'r')
		linebuffer = ''
		while True:
			data = fh.readline()
			if data == '':
				if self.wget_running():
					time.sleep(0.4)
					continue
				else:
					break
			
			line = linebuffer + data
			try: rline = line[line.rindex('\r')+1:]
			except ValueError: rline = line
			if line[-1] == '\n':
				linebuffer = ''
			else:
				linebuffer = rline
			line = rline.strip()
			if line == '':
				continue
			
			refresh = False
			m_length = re.search('^Length: (\d+)', line)
			m_name1 = re.search('^Saving to: .(.+).$', line)
			m_name2 = re.search('^Server file no newer than local file .(.+). -- not retrieving\.$', line)
			m_percent = re.search('^\s{0,2}(\d+)(\.\d+)?%', line)
			m_progress = re.search('^\s*\[', line)
			m_speed = re.search('(\d+(?:\.\d+)?)(.)/s(?:\s+eta\s+(.+))?', line)
			m_kilodots = re.search('^\s*(\d+)K\s+([., ]*)', line)
			m_completed = re.search(' saved \S+$', line)
			m_redirect = re.search('^Location: (\S+)', line)
			
			if m_length:
				self.size = int(m_length.group(1))
			if m_name1:
				self.outfile = m_name1.group(1).decode('string-escape')
				refresh = True
			if m_name2:
				self.outfile = m_name2.group(1).decode('string-escape')
				self.completed = True
				self.eta = -1
				self.eta_str = ''
				refresh = True
			if m_percent:
				self.percent = int(m_percent.group(1))
				self['status'] = S_DL
				refresh = True
			if m_progress:
				pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_speed:
				self.speed_str = m_speed.group(1) + m_speed.group(2) + '/s'
				self.speed = convert_to_bytes(m_speed.group(1) + m_speed.group(2))
				if m_speed.group(3) is not None:
					self.eta_str = m_speed.group(3)
					eta = 0
					for u, q in ('d', 24*60*60), ('h', 60*60), ('m', 60), ('s', 1):
						m = re.search('(\d+)'+u, m_speed.group(3))
						if m: eta += int(m.group(1)) * q
					self.eta = eta
				refresh = True
			if m_kilodots:
				if self.size is not None:
					kilo = int(m_kilodots.group(1))
					dots = len(''.join(m_kilodots.group(2).split()))
					self.percent = int((kilo + dots) * 1024 * 100 / self.size)
				else:
					pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_completed:
				self.completed = True
				self['status'] = S_SAVED
				self.eta = -1
				self.eta_str = ''
				refresh = True
				on_completed_download(self)
			if m_redirect:
				self.actual_url = m_redirect.group(1)
				refresh = True
			
			if self.lastline != line:
				refresh = True
			self.lastline = line
			if refresh:
				refresh_download_state(self)
		fh.close()
		self.running = False
		self['status'] = S_ERR
		self['pid'] = None
		refresh_download_state(self)
		on_ended_download(self)
	def stop(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], signal.SIGTERM)
				self['status'] = S_STOP
			except OSError, e:
				if e.errno != os.errno.ESRCH:
					raise e


def win_main_show():
	# Manage GUI
	btn_remove.hide()
	
	# Start background thread
	continous_refresh_thread = threading.Thread(target=continous_refresh, args=())
	continous_refresh_thread.daemon = True
	continous_refresh_thread.start()
	
	# Load cached downloads from object dumps
	import_downloads()

	# Parse CLI args
	main_parse_cli(sys.argv)

def main_parse_cli(argv):
	cliURLs = []
	cliOpts = []
	idx = 1
	while idx < len(argv):
		arg = argv[idx]
		if arg.startswith('-'):
			m = re.search('([^=]+)=(.*)', arg)
			if m:
				key, val = m.group(1), m.group(2)
			else:
				key = arg
				val = None
				if idx+1 < len(argv):
					argnext = argv[idx+1]
					if not argnext.startswith('-'):
						val = argnext
						idx += 1
			cliOpts.append((key, val))
		else:
			cliURLs.append(arg)
		idx += 1
	
	# Start downloads given in CLI
	if cliURLs:
		params = {'': [], '--header': [],}
		def params_def():
			params[''] += [optnam]
			if optval is not None:
				params[''] += [optval]
		for optnam, optval in cliOpts:
			if optnam == '--proxy-url':
				params['proxy'] = optval
			elif optnam == '--cookies':
				params['--header'] += ['Cookie: ' + optval]
			elif optnam == '--run-on-complete':
				params['on_complete'] = optval
			else:
				if optnam in ShortLongOptions.keys():
					optnam = ShortLongOptions[optnam]
				if optnam in ParamWidgets.keys():
					wdg, getter, putter = ParamWidgets[optnam]
					if putter is None or putter(optval):
						if getter is not None:
							dummydata = getter('x')
							if hasattr(dummydata, '__iter__'):
								if not params.has_key(optnam):
									params[optnam] = []
								params[optnam] += [optval]
							else:
								params[optnam] = optval
						else:
							params[optnam] = optval
					else:
						params_def()
				else:
					params_def()
		show_win_newdl()
		reset_parameters(params)
		p1t1.set_text('\n'.join(cliURLs)+'\n')

def act_quit():
	if any(dl.running for it, dl in iter_downloadlist()) and not question(_("Running downloads will continue in the background.\nQuit anyway?"), yes=gtk.STOCK_QUIT, default=gtk.RESPONSE_NO):
		return True
	gtk.main_quit()
	export_downloads()
	return False

def import_downloads():
	for f in os.listdir(CacheFolder):
		if re.match('^gwget-\d+\.obj$', f):
			f = os.path.join(CacheFolder, f)
			fh = open(f, 'r')
			obj = pickle.load(fh)
			fh.close()
			DownLoadList_append_new({COL_DLOBJ: obj})
			obj.resurgo()
	refresh_download_state(None, doAll=True)

def export_downloads():
	for it, dl in iter_downloadlist():
		dl.morior()
		fh = open(get_dumpfile(dl), 'w')
		pickle.dump(dl, fh)
		fh.close()

def get_dumpfile(dl):
	return dl.logfile[:-3] + 'obj'

def next_logfile():
	n = len(os.listdir(CacheFolder))
	f = 'gwget-' + str(n) + '.log'
	while os.path.exists(os.path.join(CacheFolder, f)) or any(f == os.path.basename(dl.logfile or '') for it, dl in iter_downloadlist()):
		n += 1
		f = 'gwget-' + str(n) + '.log'
	return os.path.join(CacheFolder, f)

class iter_downloadlist(object):
	def __init__(self):
		self.model = DownLoadList
		self.cur_iter = self.model.get_iter_first()
	def __iter__(self):
		return self
	def next(self):
		if self.cur_iter is None:
			raise StopIteration
		ret= (self.cur_iter, self.model[self.cur_iter][COL_DLOBJ])
		self.cur_iter = self.model.iter_next(self.cur_iter)
		return ret
	def __del__(self):
		pass

def refresh_download_state(dlobj, doAll=False):
	if threading.currentThread().name != 'MainThread':
		gtk.threads_enter()
	for it, dl in iter_downloadlist():
		row = DownLoadList[it]
		if doAll or dl == dlobj:
			if dl.outfile is None:
				row[COL_NAME] = os.path.basename(re.sub('/+$', '', urlparse.urlparse(dl.actual_url).path))
			else:
				row[COL_NAME] = os.path.basename(dl.outfile)
			row[COL_FILE_ICON] = gtk.STOCK_FILE
			if dl.percent >= 0:
				row[COL_PULSE] = -1
				row[COL_PERCENT] = dl.percent
				row[COL_PRCSTR] = str(dl.percent) + '%'
			else:
				row[COL_PERCENT] = 0
				if dl.running:
					if row[COL_PULSE] < 0:
						row[COL_PULSE] = 0
					try:
						row[COL_PULSE] += 1
					except TypeError:
						row[COL_PULSE] = 1
				else:
					if dl.completed:
						row[COL_PERCENT] = 100
						row[COL_PULSE] = gobject.constants.G_MAXINT
					else:
						row[COL_PULSE] = 0
				row[COL_PRCSTR] = ''
			row[COL_STATUS_ICON] = StatusIcon[dl['status']]
			row[COL_STATUS] = _(Status[dl['status']])
			row[COL_MESSAGE] = '<tt>' + glib.markup_escape_text(dl.lastline) + '</tt>'
			
			row[COL_SPEED_BPS] = dl.speed
			row[COL_SPEED_STR] = dl.speed_str
			row[COL_ETA_SEC] = dl.eta
			row[COL_ETA_STR] = dl.eta_str
			row[COL_ADDED_TSTMP] = dl.added_ts
			row[COL_ADDED_DATE] = str_accurate_at_time(dl.added_ts)
			
			# if the current download is selected, then refresh toolbuttons sensitivity
			if main_selection.iter_is_selected(it):
				on_selection_change(main_selection)
			if not doAll:
				break
	if threading.currentThread().name != 'MainThread':
		gtk.threads_leave()

def pulse_download(pid):
	for it, dl in iter_downloadlist():
		if dl['pid'] == pid:
			DownLoadList[it][COL_PULSE] += 1

def continous_refresh():
	while True:
		refresh_download_state(None, doAll=True)
		time.sleep(60)

def on_ended_download(dl):
	this_host = urlparse.urlparse(dl.actual_url).hostname
	start_dl = None
	for it, dl in sorted(iter_downloadlist(), key=lambda (it, dl): dl.added_ts):
		if dl.params['runnable'] and this_host == urlparse.urlparse(dl.actual_url).hostname:
			if dl['status'] in [S_INIT, S_DL]:
				start_dl = None
				break
			if start_dl is None and dl['status'] in [S_QUEUE]:
				start_dl = dl
	if start_dl is not None:
		start_dl.start()

def setxattributes(dl):
	attrs = {XATTR_URI: dl.actual_url}
	if dl.params.has_key('--referer'):
		attrs[XATTR_REFERER] = dl.params['--referer']
	set_xattrs_file(dl.outfile, attrs)

def on_completed_download(dl):
	setxattributes(dl)
	if dl.params.has_key('on_complete'):
		s = dl.params['on_complete']
		SQ = '\''
		esc_filename = SQ + dl.outfile.replace(SQ, SQ+'\\'+SQ+SQ) + SQ
		shcmd = s.replace('{}', esc_filename)
		run_detached('sh', ['-c', shcmd])

def DownLoadList_append_new(d):
	# COL_DLOBJ, COL_NAME, COL_FILE_ICON, COL_PXB, COL_ADDED_TSTMP, COL_ADDED_DATE, 
	#   COL_PRCSTR, COL_PERCENT, COL_PULSE, COL_SPEED_BPS, COL_SPEED_STR, 
	#   COL_ETA_SEC, COL_ETA_STR, COL_STATUS_ICON, COL_STATUS, COL_MESSAGE
	# DownLoadList = gtk.ListStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, int, str, 
	#   str, float, int, float, str, 
	#   int, str, str, str, str)
	# it = DownLoadList.append([dl, os.path.basename(url), gtk.STOCK_FILE, None, int(time.time()), str_accurate_at_time(time.time()), 
	#   '', 0, 0, -1, '', 
	#   -1, '', gtk.STOCK_MEDIA_STOP, _(Status[S_QUEUE]), ''])
	row = [None, '', '', None, 0, '',  '', 0, 0, -1, '',  -1, '', '', '', '']
	for idx, val in d.iteritems():
		row[idx] = val
	return DownLoadList.append(row)

def start_new_download(url, params, start=True):
	dl = Download(url, params)
	it = DownLoadList_append_new({COL_DLOBJ: dl})
	refresh_download_state(dl)
	if start:
		dl.start()
	return it

def reset_parameters(params={}):
	for wdg in p1t1, p2c1, p2t1, p3t1, p4e2, p4e3, p4e4, p4e5, p4e6, p4e7, p4e8:
		wdg.set_text('')
	p1s2.set_value(0)
	p4s1.set_value(1)
	for flag, (wdg, getter, putter) in ParamWidgets.iteritems():
		if params.has_key(flag):
			data = params[flag]
			if putter is not None:
				data = putter(data)
			if type(data) == int:
				wdg.set_value(data)
			elif data:
				wdg.set_text(data)
			# TODO workaround for non-Cookie --header's

def show_win_newdl():
	win_newdl.show_all()
	for n in reversed(range(0, note.get_n_pages())):
		note.set_current_page(n)
	p1t1.grab_focus()



### Interface procedures ###

def act_new():
	show_win_newdl()
	reset_parameters()

def act_start_all():
	for it, dl in iter_downloadlist():
		if not dl.running and not dl.completed:
			act_start(None, dl)

def act_pause_all():
	for it, dl in iter_downloadlist():
		if dl.running:
			act_pause(None, dl)

def act_clear_completed():
	for it, dl in iter_downloadlist():
		if dl.completed:
			act_clear_download(it, dl)

def act_options():
	pass


def act_open_file(it, dl):
	if dl.outfile is not None:
		run_detached('mimeopen-gui', [dl.outfile])

def act_open_folder(it, dl):
	run_detached('mimeopen-gui', [dl.params['--directory-prefix']])

def act_start(it, dl):
	dl.start()

def act_refetch(it, dl):
	if dl.outfile is not None:
		delete(dl.outfile)
	dl.start()

def act_pause(it, dl):
	dl.stop()

def act_remove_download(it, dl, force=False):
	if not dl.running and dl.outfile is not None:
		if not dl.completed or force or question(_("Would you like to <b>delete completed</b> file?\nURL: <tt>%s</tt>\nFile: <tt>%s</tt>") % (glib.markup_escape_text(dl.original_url), glib.markup_escape_text(dl.outfile or '')), yes=gtk.STOCK_DELETE, default=gtk.RESPONSE_NO):
			delete(dl.outfile)

def act_clear_download(it, dl):
	if not dl.running:
		if not dl.completed and dl.outfile is not None and os.path.exists(dl.outfile):
			try:
				if question(_("This download is not completed.\nWould you like to <b>delete partial</b> file?\nURL: <tt>%s</tt>\nFile: <tt>%s</tt>") % (glib.markup_escape_text(dl.original_url), glib.markup_escape_text(dl.outfile or '')), yes=gtk.STOCK_DELETE, cancelable=True, default=gtk.RESPONSE_CANCEL):
					act_remove_download(it, dl, force=True)
			except DialogCancel:
				return
		if dl.logfile is not None:
			untrack_download_file(dl)
		del DownLoadList[it]

def untrack_download_file(dl):
	delete(get_dumpfile(dl))
	delete(dl.logfile)

def act_show_log(it, dl):
	try:
		fh = open(dl.logfile, 'r')
	except IOError, e:
		display_error(e)
	else:
		win_log = gtk.Window()
		txv = ScrolledTextView()
		win_log.set_default_size(675, 345)
		win_log.set_title(_("Log - %s") % (dl.original_url))
		win_log.set_icon_name('emblem-downloads')
		win_log.connect('delete-event', lambda w,e: w.destroy())
		add_key_binding(win_log, 'Escape', lambda a,b,c,d: win_log.destroy() or True)
		win_log.set_transient_for(win_main)
		win_log.set_modal(True)
		win_log.add(txv)
		txv.set_text(''.join(fh.readlines()))
		txv.set_editable(False)
		win_log.show_all()
		fh.close()

def act_props(it, dl):
	#print dl.__dict__
	show_win_newdl()
	reset_parameters(dl.params)
	p1t1.set_text(dl.original_url)



def act_on_selection(func, maxi=None):
	iters = []
	for itpath in main_selection.get_selected_rows()[1]:
		iters.append(DownLoadList.get_iter(itpath))
	if maxi is None or len(iters) <= maxi:
		for it in iters:
			func(it, DownLoadList[it][COL_DLOBJ])

def on_selection_change(selection):
	iters = map(lambda p: DownLoadList.get_iter(p), selection.get_selected_rows()[1])
	dls = map(lambda it: DownLoadList[it][COL_DLOBJ], iters)
	num = len(iters)
	btn_resume.set_sensitive(num>0 and all(not dl.running and not(dl.completed and os.path.exists(dl.outfile)) for dl in dls))
	btn_pause.set_sensitive(num>0 and all(dl.running for dl in dls))
	btn_remove.set_sensitive(num>0 and all(dl.outfile is not None and not dl.running for dl in dls))
	btn_clear.set_sensitive(num>0 and all(not dl.running for dl in dls))
	btn_props.set_sensitive(num == 1)

def on_context_menu(menuitem, function):
	it = ContextMenu.get_data('iterator')
	dl = DownLoadList[it][COL_DLOBJ]
	function(it, dl)
	return True

def event_masked(event):
	return any(event.state & getattr(gtk.gdk, mask+'_MASK') for mask in ['CONTROL','SHIFT','MOD4','MOD5','META'])

def popup_context_menu(it, event, button=None, placement_func=None):
	dl = DownLoadList[it][COL_DLOBJ]
	ContextMenu.set_data('iterator', it)
	cmi_open.set_sensitive(dl.outfile is not None)
	cmi_remove.set_sensitive(dl.outfile is not None and not dl.running and os.path.exists(dl.outfile))
	cmi_refetch.set_sensitive(not dl.running)
	cmi_resume.set_sensitive(not dl.running and not(dl.completed and os.path.exists(dl.outfile)))
	cmi_pause.set_sensitive(dl.running)
	cmi_clear.set_sensitive(not dl.running)
	if button is None: button = event.button
	ContextMenu.popup(None, None, placement_func, button, event.time)

def on_treeview_click(tree, event):
	if event_masked(event):
		return False
	pathinfo = main_list.get_path_at_pos(int(event.x), int(event.y))
	if pathinfo is not None:
		path, col, cellx, celly = pathinfo
		it = DownLoadList.get_iter(path)
		dl = DownLoadList[it][COL_DLOBJ]
		if event.type == gtk.gdk.BUTTON_PRESS and event.button == 3:
			main_selection.unselect_all()
			main_selection.select_iter(it)
			popup_context_menu(it, event)
			return True
		elif event.type == gtk.gdk._2BUTTON_PRESS and event.button == 1:
			act_open_file(it, dl)
			return True
	return False

def on_treeview_key(tree, event):
	if event_masked(event):
		return False
	if event.keyval == gtk.gdk.keyval_from_name('Delete'):
		act_on_selection(act_clear_download)
		return True
	rows = main_selection.get_selected_rows()[1]
	if event.keyval == gtk.gdk.keyval_from_name('Menu'):
		if len(rows) == 1:
			it = DownLoadList.get_iter(rows[0])
			x, y = tree.window.get_origin()
			popup_context_menu(it, event, 3, placement_func=lambda d: (x, y, True))
			return True
	if event.keyval in map(gtk.gdk.keyval_from_name, ['Return', 'KP_Enter']):
		if len(rows) == 1:
			it = DownLoadList.get_iter(rows[0])
			dl = DownLoadList[it][COL_DLOBJ]
			act_open_file(it, dl)
		return True
	return False


## New download window
def new_download(start=True, open=False):
	params = {}
	for flag, (wdg, getter, putter) in ParamWidgets.iteritems():
		data = wdg.get_text()
		if getter is not None:
			data = getter(data)
		if data:
			if hasattr(data, '__iter__') and params.has_key(flag):
				params[flag] += data
			else:
				params[flag] = data
	if open:
		params['on_complete'] = 'mimeopen-gui {}'
	params['runnable'] = start
	
	main_selection.unselect_all()
	uniq_url = {}
	uniq_host = {}
	for url in p1t1.get_text().split():
		if not uniq_url.has_key(url):
			this_host = urlparse.urlparse(url).hostname
			start_this = False if not start else not any(this_host == host for host in uniq_host.iterkeys())
			it = start_new_download(url, params, start=start_this)
			main_selection.select_iter(it)
			uniq_url[url] = 1
			uniq_host[this_host] = 1
	win_newdl.hide()

def DnD_motion(wdg, context, x, y, time):
	action = None
	for act in gtk.gdk.ACTION_COPY, gtk.gdk.ACTION_MOVE:
		if context.suggested_action & act:
			action = act
			break
	if 'text/plain' in context.targets and action is not None:
		wdg.drag_highlight()
		context.drag_status(action, time)
		return True
	return False

def DnD_accept(wdg, context, x, y, time):
	accepted = False
	typ = 'text/plain'
	if typ in context.targets:
		wdg.drag_get_data(context, typ, time)
		accepted = True
	context.drop_reply(accepted, time)
	wdg.drag_unhighlight()
	return True

def DnD_receive(wdg, context, x, y, selectiondata, info, time):
	success = False
	if selectiondata.get_length() > -1:
		typ = selectiondata.get_data_type()
		if typ == 'text/plain':
			urls = '\n'.join(selectiondata.get_text().split())+'\n'
			act_new()
			p1t1.set_text(urls)
			if context.action == gtk.gdk.ACTION_MOVE:
				new_download()
			success = True
	context.finish(success, False, time)
	return True

class GwgetService(dbus.service.Object):
	def __init__(self, win_main):
		self.win = win_main
		bus_name = dbus.service.BusName(APPNAME, bus = dbus.SessionBus())
		dbus.service.Object.__init__(self, bus_name, '/'+APPNAME.replace('.', '/'))
	@dbus.service.method(dbus_interface = APPNAME)
	def new_download(self, args):
		gtk.threads_enter()
		self.win.present()
		main_parse_cli(args)
		gtk.threads_leave()



### Main ###

gettext.textdomain(PROGNAME)
_ = gettext.gettext
LastFolder = os.getcwd()
XATTR_URI = 'user.xdg.origin.url'
XATTR_REFERER = 'user.xdg.referrer.url'
CacheFolder = os.path.join(os.environ['HOME'], '.cache', 'gwget')
COL_DLOBJ, COL_NAME, COL_FILE_ICON, COL_PXB, COL_ADDED_TSTMP, COL_ADDED_DATE, COL_PRCSTR, COL_PERCENT, COL_PULSE, COL_SPEED_BPS, COL_SPEED_STR, COL_ETA_SEC, COL_ETA_STR, COL_STATUS_ICON, COL_STATUS, COL_MESSAGE = range(16)
S_QUEUE, S_INIT, S_DL, S_SAVED, S_ERR, S_STOP = range(6)
Status = {
	S_QUEUE: "Queued",
	S_INIT: "Init",
	S_DL: "Download",
	S_SAVED: "Saved",
	S_ERR: "Failed",
	S_STOP: "Paused",
}
StatusIcon = {
	S_QUEUE: gtk.STOCK_MEDIA_STOP,
	S_INIT: 'media-seek-forward',
	S_DL: 'media-playback-start',
	S_SAVED: gtk.STOCK_APPLY,
	S_ERR: gtk.STOCK_NO,
	S_STOP: gtk.STOCK_MEDIA_PAUSE,
}



if '--help' in sys.argv or '-h' in sys.argv:
	print """Usage: gwget [gwget options] [wget options]
gwget options:
  --proxy-url
  --cookies
  --run-on-complete"""
	raise SystemExit(0)

# Check if application is already running
if dbus.SessionBus().request_name(APPNAME) != dbus.bus.REQUEST_NAME_REPLY_PRIMARY_OWNER:
	stderr(_("Already running.")+'\n')
	method = dbus.SessionBus().get_object(APPNAME, '/'+APPNAME.replace('.', '/')).get_dbus_method('new_download')
	method(sys.argv)
	raise SystemExit(0)

gtk.gdk.threads_init()
mkdir(CacheFolder)


### Build GUI ###

## Main window

# Declare main window's widgets
win_main = gtk.Window()
box_main = gtk.VBox()
main_toolbar = gtk.Toolbar()
scroller = gtk.ScrolledWindow()
DownLoadList = gtk.ListStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, float, str, str, float, int, float, str, int, str, str, str, str)
main_list = gtk.TreeView(DownLoadList)
main_selection = main_list.get_selection()
ContextMenu = gtk.Menu()
cmi_open = StockMenuItem(None, gtk.STOCK_OPEN)
cmi_folder = StockMenuItem(_("Open Folder"), gtk.STOCK_DIRECTORY)
cmi_remove = StockMenuItem(_("Delete File"), gtk.STOCK_DELETE)
cmi_refetch = StockMenuItem(_("Re-download"), gtk.STOCK_REFRESH)
cmi_resume = StockMenuItem(_("Resume"), gtk.STOCK_MEDIA_PLAY)
cmi_pause = StockMenuItem(_("Pause"), gtk.STOCK_MEDIA_PAUSE)
cmi_clear = StockMenuItem(_("Clear"), gtk.STOCK_CLEAR)
cmi_log = StockMenuItem(_("Show Log"), gtk.STOCK_INFO)
cmi_props = StockMenuItem(None, gtk.STOCK_PROPERTIES)


# Configure main window's widgets
win_main.set_default_size(950, 450)
win_main.set_title(_("Downloads"))
win_main.set_icon_name('emblem-downloads')
start_evt = win_main.connect('map-event', lambda w,e: (win_main.disconnect(start_evt), win_main_show()))
win_main.connect('delete-event', lambda w,e: act_quit())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_new())
add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_start_all())
add_key_binding(win_main, '<Control>k', lambda a,b,c,d: act_pause_all())
add_key_binding(win_main, '<Control>l', lambda a,b,c,d: act_on_selection(act_show_log, 1))
add_key_binding(win_main, '<Control>p', lambda a,b,c,d: act_on_selection(act_props, 1))
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_options())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())

toolbuttons = [
	(None, gtk.STOCK_NEW, None, act_new),
	(_("Resume All"), gtk.STOCK_MEDIA_PLAY, None, act_start_all),
	(_("Pause All"), gtk.STOCK_MEDIA_PAUSE, None, act_pause_all),
	(_("Clear Completed"), gtk.STOCK_CLEAR, None, act_clear_completed),
	(None, None, None, 'separator'),
	(_("Resume"), gtk.STOCK_MEDIA_PLAY, None, (act_on_selection, act_start)),
	(_("Pause"), gtk.STOCK_MEDIA_PAUSE, None, (act_on_selection, act_pause)),
	(_("Delete File"), gtk.STOCK_DELETE, None, (act_on_selection, act_remove_download)),
	(_("Clear"), gtk.STOCK_CLEAR, None, (act_on_selection, act_clear_download)),
	(None, gtk.STOCK_PROPERTIES, None, (act_on_selection, act_props)),
	(None, None, None, 'space'),
	(None, gtk.STOCK_PREFERENCES, None, act_options),
	(None, gtk.STOCK_QUIT, None, act_quit),
]
x, x, x, x, x_, btn_resume, btn_pause, btn_remove, btn_clear, btn_props, x_, x, x \
= load_toolitems(main_toolbar, toolbuttons)
on_selection_change(main_selection)


tvc = gtk.TreeViewColumn(_("Filename"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_NAME)
tvc.set_sort_indicator(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_NAME)
tvc.add_attribute(cr_pix, 'icon-name', COL_FILE_ICON)
tvc.add_attribute(cr_pix, 'pixbuf', COL_PXB)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Progress"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_PERCENT)
tvc.set_sort_indicator(True)
cr_prc = gtk.CellRendererProgress()
tvc.pack_start(cr_prc, True)
tvc.add_attribute(cr_prc, 'text', COL_PRCSTR)
tvc.add_attribute(cr_prc, 'value', COL_PERCENT)
tvc.add_attribute(cr_prc, 'pulse', COL_PULSE)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Status"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_STATUS)
tvc.set_sort_indicator(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_STATUS)
tvc.add_attribute(cr_pix, 'icon-name', COL_STATUS_ICON)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Speed"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_SPEED_BPS)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_SPEED_STR)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Added"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_ADDED_TSTMP)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_ADDED_DATE)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("ETA"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_ETA_SEC)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_ETA_STR)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Message"))
tvc.set_sort_column_id(COL_MESSAGE)
tvc.set_sort_indicator(True)
tvc.set_resizable(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'markup', COL_MESSAGE)
main_list.append_column(tvc)

main_list.set_rules_hint(True)
main_list.set_reorderable(True)
main_list.connect('button-press-event', on_treeview_click)
main_list.connect('key-press-event', on_treeview_key)
main_list.drag_dest_set(0, [], 0)
main_list.connect('drag-motion', DnD_motion)
main_list.connect('drag-drop', DnD_accept)
main_list.connect('drag-data-received', DnD_receive)
main_selection.set_mode(gtk.SELECTION_MULTIPLE)
main_selection.connect('changed', on_selection_change)
cmi_open.connect('activate', on_context_menu, act_open_file)
cmi_folder.connect('activate', on_context_menu, act_open_folder)
cmi_remove.connect('activate', on_context_menu, act_remove_download)
cmi_refetch.connect('activate', on_context_menu, act_refetch)
cmi_resume.connect('activate', on_context_menu, act_start)
cmi_pause.connect('activate', on_context_menu, act_pause)
cmi_clear.connect('activate', on_context_menu, act_clear_download)
cmi_log.connect('activate', on_context_menu, act_show_log)
cmi_props.connect('activate', on_context_menu, act_props)


# Pack main window's widgets
win_main.add(box_main)
box_main.pack_start(main_toolbar, 0, 1)
box_main.pack_start(scroller, 1, 1)
scroller.add_with_viewport(main_list)
scroller.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
ContextMenu.append(cmi_open)
ContextMenu.append(cmi_folder)
ContextMenu.append(cmi_remove)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_refetch)
ContextMenu.append(cmi_resume)
ContextMenu.append(cmi_pause)
ContextMenu.append(cmi_clear)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_log)
ContextMenu.append(cmi_props)
ContextMenu.show_all()


## New Download window

# Declare new download window's widgets
win_newdl = gtk.Window()
box_newdl = gtk.VBox()
note = gtk.Notebook()
page1 = gtk.VBox()
p1x1 = gtk.HBox()
p1l1 = gtk.Label(_("URLs"))
p1t1 = ScrolledTextView()
p1c1 = FileChooserEntry(label=_("Target Folder"), path=LastFolder, action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
p1x2 = gtk.HBox(spacing=2)
p1l2a = gtk.Label(_("Bandwidth limit"))
p1a2 = gtk.Adjustment(value=0, lower=0, upper=gobject.constants.G_MAXINT, step_incr=1, page_incr=10)
p1s2 = gtk.SpinButton(p1a2)
p1l2b = gtk.Label()
page2 = gtk.VBox()
p2x1 = gtk.VBox()
p2c1 = FileChooserEntry(label=_("Cookie file"), action=gtk.FILE_CHOOSER_ACTION_OPEN)
p2l1 = gtk.Label(_("Custom Cookies per line in NAME=VALUE format:"))
p2t1 = ScrolledTextView()
page3 = gtk.VBox()
p3l1 = gtk.Label(_("POST parameters per line in NAME=VALUE format:\nURL encoding is not necessary"))
p3t1 = ScrolledTextView()
page4 = gtk.VBox()
p4x1 = gtk.HBox(spacing=2)
p4l1a = gtk.Label(_("Attempts"))
p4a1 = gtk.Adjustment(value=1, lower=0, upper=gobject.constants.G_MAXINT, step_incr=1, page_incr=10)
p4s1 = gtk.SpinButton(p4a1)
p4l1b = gtk.Label()
p4e2 = LabelledEntry(label=_("Username"))
p4e3 = LabelledEntry(label=_("Password"))
p4e4 = LabelledEntry(label=_("Proxy URL"))
p4e5 = LabelledEntry(label=_("Referer"))
p4e6 = LabelledEntry(label=_("User Agent"))
p4e7 = LabelledEntry(label=_("Custom options"), tooltip=_("type further options for wget\nsee 'wget --help' or 'man wget'"))
p4e8 = LabelledEntry(label=_("Run on complete"), tooltip=_("type a shell command-line\npair of curly brackets are substituted with downloaded file name\nexample: xdg-open {} && rm {}"))
btns_newdl = gtk.HBox(spacing=5)
btn_new_save = StockButton(label=_("Download"), stock=gtk.STOCK_SAVE, tooltip='Ctrl-Enter')
btn_new_open = StockButton(stock=gtk.STOCK_OPEN)
btn_new_queue = StockButton(label=_("Queue"), stock=gtk.STOCK_ADD, tooltip='Ctrl-Shift-Enter')
btn_new_no = StockButton(stock=gtk.STOCK_CANCEL, tooltip='Esc')

# Configure new download window's widgets
win_newdl.set_transient_for(win_main)
win_newdl.set_modal(True)
win_newdl.set_title(_("New Download"))
win_newdl.set_icon_name('emblem-downloads')
win_newdl.connect('delete-event', lambda w,e: w.hide() or True)
add_key_binding(win_newdl, 'Escape', lambda a,b,c,d: win_newdl.hide() or True)
add_key_binding(win_newdl, '<Control>Return', lambda a,b,c,d: new_download() or True)
add_key_binding(win_newdl, '<Control><Shift>Return', lambda a,b,c,d: new_download(start=False) or True)
for label in p1l1, p2l1, p1l2a, p1l2b, p3l1, p4l1a, p4l1b:
	label.set_alignment(0, 0)
	label.set_padding(4, 5)
for spinner in p1s2, p4s1:
	spinner.set_numeric(True)
	spinner.set_alignment(1.0)
p1l2b.set_markup(_("kB/s <small><i>(0 = unlimited)</i></small>"))
p4l1b.set_markup(_("<small><i>(0 = infinite)</i></small>"))
p4e3.set_visibility(False)
btns_newdl.set_border_width(5)
btn_new_save.connect('clicked', lambda b: new_download())
btn_new_open.connect('clicked', lambda b: new_download(open=True))
btn_new_queue.connect('clicked', lambda b: new_download(start=False))
btn_new_no.connect('clicked', lambda b: win_newdl.hide() or True)

ParamWidgets = {
	'--directory-prefix': (p1c1, lambda a: a if a!='' else os.getcwd(), None),
	'--load-cookies': (p2c1, None, None),
	'--header': (p2t1, \
		lambda a: ['Cookie: ' + '; '.join(filter(lambda k: len(k), a.split('\n')))],\
		lambda b: '\n'.join(k.strip() for k in ';'.join(re.sub('^Cookie:\s+', '', h) for h in filter(lambda h: re.search('^Cookie: ', h), b)).split(';'))+'\n' ),
	'--post-data': (p3t1, \
		lambda a: urllib.urlencode(dict(map(lambda p: (p if p.find('=')>-1 else p+'=').split('=', 1), filter(lambda p: len(p), a.split('\n'))))),\
		lambda b: '\n'.join(urllib.unquote(p) for p in b.split('&'))+'\n' ),
	'--tries': (p4s1, None, lambda b: int(b) ),
	'--user': (p4e2, None, None),
	'--password': (p4e3, None, None),
	'proxy': (p4e4, None, None),
	'--referer': (p4e5, None, None),
	'--user-agent': (p4e6, None, None),
	'--limit-rate': (p1s2, lambda a: a+'k', lambda b: int(convert_to_bytes(b, 'k')) ),
	'': (p4e7, lambda a: a.split(), lambda b: ' '.join(b) ),
	'on_complete': (p4e8, None, None),
}
ShortLongOptions = {
	'-P': '--directory-prefix',
	'-t': '--tries',
	'-U': '--user-agent',
}

# Pack new download window's widgets
win_newdl.add(box_newdl)
box_newdl.pack_start(note, 1, 1)
note.append_page(page1, gtk.Label(_("Basic")))
page1.pack_start(p1x1, 1, 1)
p1x1.pack_start(p1l1, 0, 1)
p1x1.pack_start(p1t1, 1, 1)
page1.pack_start(p1c1, 0, 1)
page1.pack_start(p1x2, 0, 1)
p1x2.pack_start(p1l2a, 0, 1)
p1x2.pack_start(p1s2, 0, 1)
p1x2.pack_start(p1l2b, 0, 1)
note.append_page(page2, gtk.Label(_("Cookies")))
page2.pack_start(p2x1, 1, 1)
p2x1.pack_start(p2c1, 0, 1)
p2x1.pack_start(p2l1, 0, 1)
p2x1.pack_start(p2t1, 1, 1)
note.append_page(page3, gtk.Label(_("POST")))
page3.pack_start(p3l1, 0, 0)
page3.pack_start(p3t1, 1, 1)
note.append_page(page4, gtk.Label(_("Advanced")))
page4.pack_start(p4x1, 0, 1)
p4x1.pack_start(p4l1a, 0, 1)
p4x1.pack_start(p4s1, 0, 1)
p4x1.pack_start(p4l1b, 0, 1)
page4.pack_start(p4e2, 0, 1)
page4.pack_start(p4e3, 0, 1)
page4.pack_start(p4e4, 0, 1)
page4.pack_start(p4e5, 0, 1)
page4.pack_start(p4e6, 0, 1)
page4.pack_start(p4e7, 0, 1)
page4.pack_start(p4e8, 0, 1)
box_newdl.pack_start(btns_newdl, 0, 0)
btns_newdl.pack_start(btn_new_save, 0, 1)
btns_newdl.pack_start(btn_new_open, 0, 1)
btns_newdl.pack_start(btn_new_queue, 0, 1)
btns_newdl.pack_start(btn_new_no, 0, 1)



win_main.show_all()
dbus_service = GwgetService(win_main)
gtk.main()
