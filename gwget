#!/usr/bin/env python

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import re
import argparse
import xattr
import threading
import time
import functools
from urllib import urlencode


def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = '%s (#%d)\n%s' % (e.strerror, e.errno, e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

class DialogCancel(Exception):
	pass

def question(msg, yes=None, parent=None, cancelable=False, default=gtk.RESPONSE_YES):
	dlg = gtk.MessageDialog(parent, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_NONE)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if yes is None:
		dlg.add_buttons(gtk.STOCK_YES, gtk.RESPONSE_YES)
	else:
		if type(yes) in [type(()), type([])]:
			btn_yes = StockButton(label=yes[0], stock=yes[1])
			dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
			btn_yes.show()
		else:
			dlg.add_buttons(yes, gtk.RESPONSE_YES)
	dlg.add_buttons(gtk.STOCK_NO, gtk.RESPONSE_NO)
	if cancelable:
		dlg.add_buttons(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		add_key_binding(dlg, 'Escape', lambda a,b,c,d: dlg.response(gtk.RESPONSE_CANCEL) or True)
	dlg.set_default_response(default)
	resp = dlg.run()
	dlg.destroy()
	if resp == gtk.RESPONSE_CANCEL:
		raise DialogCancel()
	return (resp == gtk.RESPONSE_YES)

def set_dialog_icon_name(dlg, icon):
	img = dlg.get_content_area().children()[0].children()[0]
	img.set_from_icon_name(icon, gtk.ICON_SIZE_DIALOG)

def create_choose_dialog(action, path=None, init=None):
	btn_accept_stock = gtk.STOCK_OPEN
	if action in [gtk.FILE_CHOOSER_ACTION_SAVE, gtk.FILE_CHOOSER_ACTION_CREATE_FOLDER]:
		btn_accept_stock = gtk.STOCK_SAVE
	dlg = gtk.FileChooserDialog(parent=None, action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	
	if action in [gtk.FILE_CHOOSER_ACTION_OPEN, gtk.FILE_CHOOSER_ACTION_SAVE] and path is not None:
		dlg.set_filename(path)
	else:
		dlg.set_current_folder(path or Var.LastFolder)
	if init is not None:
		dlg.set_current_name(init)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	return dlg

def choose_dialog(action, path=None, init=None):
	selected = None
	dlg = create_choose_dialog(action, path=path, init=init)
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			# 'Working Dir' button
			dlg.set_current_folder(os.getcwd())
		else:
			break
	Var.LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename=filename)

def choose_folder(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, folder=folder)

def choose_open_file(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN, folder=folder)

class FileChooserEntry(gtk.HBox):
	def __init__(self, label='', init='', action=gtk.FILE_CHOOSER_ACTION_OPEN):
		super(self.__class__, self).__init__(spacing=2)
		self.label = gtk.Label(label)
		self.label.set_alignment(0, 0)
		self.label.set_padding(2, 8)
		self.entry = gtk.Entry()
		self.entry.set_text(init)
		self.button = StockButton(label='', stock=gtk.STOCK_OPEN, icon_size=gtk.ICON_SIZE_MENU)
		self.button.connect('clicked', self.choose, action)
		self.pack_start(self.label, 0, 0)
		self.pack_start(self.entry, 1, 1)
		self.pack_start(self.button, 0, 0)
	def get_text(self):
		return self.entry.get_text()
	def set_text(self, text):
		return self.entry.set_text(text)
	def get_label(self):
		return self.label.get_text()
	def set_label(self, text):
		return self.label.set_text(text)
	def choose(self, btn, action):
		p = choose_dialog(action, path=self.get_text())
		if p is not None:
			self.set_text(p)

class ScrolledTextView(gtk.ScrolledWindow):
	def __init__(self):
		super(self.__class__, self).__init__()
		self.TextView = gtk.TextView()
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.set_shadow_type(gtk.SHADOW_IN)
		self.add(self.TextView)
		self.TextView.set_editable(True)
		self.TextView.set_wrap_mode(gtk.WRAP_NONE)
		self.TextView.modify_font(pango.FontDescription('monospace'))
		for attr, val in gtk.TextView.__dict__.iteritems():
			# make TextView class methods inherited
			if not attr.startswith('_') and not hasattr(self, attr) and callable(val):
				self.__dict__[attr] = functools.partial(val, self.TextView)
	def get_text(self):
		bufr = self.TextView.get_buffer()
		return bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True)
	def set_text(self, text):
		bufr = self.TextView.get_buffer()
		return bufr.set_text(text)
	def grab_focus(self):
		return self.TextView.grab_focus()

class LabelledEntry(gtk.HBox):
	def __init__(self, label='', spacing=2):
		super(self.__class__, self).__init__(spacing=spacing)
		self.Label = gtk.Label(label)
		self.Entry = gtk.Entry()
		self.Label.set_alignment(0, 0)
		self.Label.set_padding(4, 5)
		self.pack_start(self.Label, 0, 1)
		self.pack_start(self.Entry, 1, 1)
		for cname in 'Entry', 'Label':
			for attr, val in getattr(gtk, cname).__dict__.iteritems():
				if not attr.startswith('_') and not hasattr(self, attr) and callable(val):
					self.__dict__[attr] = functools.partial(val, getattr(self, cname))


def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_markup(self, markup):
		x, lbl = self.__get_children()
		lbl.set_markup(markup)

class StockMenuItem(gtk.ImageMenuItem):
	def __init__(self, label=None, stock_id=None, accel_group=None):
		gtk.ImageMenuItem.__init__(self, stock_id, accel_group)
		if label is not None:
			self.set_label(label)

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left in toolitems:
		hid = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(_(tip))
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		else:
			Lstocklabel = None
			st = gtk.stock_lookup(stock)
			if st:
				Lstocklabel = re.sub('_', '', st[1])
			if label is not None:
				Llabel = _(label)
			else:
				Llabel = Lstocklabel
			if tip is not None:
				Ltip = _(tip)
			else:
				if label is not None:
					Ltip = Llabel
				else:
					Ltip = Lstocklabel
			tbi = StockToolButton(label=Llabel, stock=stock, tooltip=Ltip)
			tbi.set_data('stock', stock)
			tbi.set_data('label', label)
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

## OS functions

def mkdir(d):
	p = os.path.dirname(d)
	if not os.path.exists(p):
		mkdir(p)
	try:
		os.mkdir(d)
	except OSError, e:
		if e.errno != os.errno.EEXIST:
			raise e

def stderr(s):
	sys.stderr.write(s)

def delete(f, warn=True):
	try:
		os.unlink(f)
	except OSError, e:
		if warn:
			stderr('%s: error %d: %s\n' % (e.filename, e.errno, e.strerror))
		if e.errno != os.errno.ENOENT:
			display_error(e)
			return False
	return True

def run_detached(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			try:
				os.execvp(cmd, args)
			except OSError:
				pass
			os._exit(127)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

class Readlines(object):
	def __init__(self, handle):
		self.handle = handle
	def __iter__(self):
		return self
	def next(self):
		s = self.handle.readline()
		if s == '':
			raise StopIteration
		return s
	def __del__(self):
		pass


### Private methods ###

class Download(object):
	def __init__(self, url, params={}):
		self.original_url = url
		self.params = params
		self.progress_type = 'bar:force'
		#self.progress_type = 'dot:default'
		self.logfile = None
		self.outfile = None
		self.Lock = threading.Lock()
		self._pid = None
		self.init()
	def init(self):
		self['status'] = S_QUEUE
		self.completed = False
		self.running = False
		self.size = None
		self.percent = -1
		self.lastline = ''
	def __getitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			self.Lock.release()
			return getattr(self, '_' + key)
		else:
			raise KeyError()
	def __setitem__(self, key, val):
		self.Lock.acquire(True)
		if key == 'status' and hasattr(self, '_status'):
			if (self._status == S_STOP and val == S_DL) or (val == S_ERR and self._status in [S_SAVED, S_STOP]):
				self.Lock.release()
				return False
		setattr(self, '_' + key, val)
		self.Lock.release()
		return True
	def __delitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			delattr(self, '_' + key)
		self.Lock.release()
	def spawn_wget(self, args=[]):
		reader, writer = os.pipe()
		pid = os.fork()
		if pid == 0:
			os.putenv('LANG', 'C')
			if self.params.has_key('proxy_url'):
				proxy = self.params['proxy_url']
				os.putenv('http_proxy', proxy)
				os.putenv('https_proxy', proxy)
				os.putenv('ftp_proxy', proxy)
			os.close(reader)
			os.dup2(writer, sys.stdout.fileno())
			os.dup2(writer, sys.stderr.fileno())
			sys.stdin.close()
			os.closerange(3, 255)
			os.execvp('wget', ['wget'] + args)
			os._exit(127)
		os.close(writer)
		return os.fdopen(reader, 'r')
	def start(self):
		if self['pid'] is not None:
			return
		self.init()
		refresh_download_state(self)
		if self.logfile is None:
			self.logfile = next_logfile()
		if not delete(self.logfile, warn=False):
			return
		
		wget_args = []
		for k, v in self.params.iteritems():
			if k.startswith('-'):
				if hasattr(v, '__iter__'):
					for v1 in v:
						wget_args.append(k)
						wget_args.append(v1)
				else:
					if k.startswith('--') and v is False:
						k = '--no-' + k[2:]
					wget_args.append(k)
					if v is not True and v is not False and v is not None:
						wget_args.append(v)
			elif k == '':
				# append custom options
				for v1 in v:
					wget_args.append(v1)
		wget_args += ['--verbose', '--output-file', self.logfile, \
		  '--background', '--continue', '--progress', self.progress_type, \
		  '--adjust-extension', '--content-disposition', '--retry-connrefused', \
		  '--auth-no-challenge']
		wget_args.append(self.original_url)
		try:
			readhandle = self.spawn_wget(wget_args)
		except OSError, e:
			display_error(e)
			return
		
		self['status'] = S_INIT
		# TODO readlines into thread
		for line in Readlines(readhandle):
			line = line.strip()
			self.lastline = line
			m_pid = re.search('pid (\d+)', line)
			if m_pid:
				self['pid'] = int(m_pid.group(1))
				break
		readhandle.close()
		if self['pid']:
			t = threading.Thread(target=self.watch_log, args=())
			t.daemon = True
			t.start()
		else:
			self['status'] = S_ERR
		refresh_download_state(self)
	def wget_running(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], 0)
				return True
			except OSError:
				pass
		return False
	def watch_log(self):
		while not os.path.exists(self.logfile):
			time.sleep(1)
		self.running = True
		fh = open(self.logfile, 'r')
		linebuffer = ''
		while True:
			data = fh.readline()
			if data == '':
				if self.wget_running():
					time.sleep(0.4)
					continue
				else:
					break
			
			line = linebuffer + data
			try: rline = line[line.rindex('\r')+1:]
			except ValueError: rline = line
			if line[-1] == '\n':
				linebuffer = ''
			else:
				linebuffer = rline
			line = rline.strip()
			if line == '':
				continue
			
			refresh = False
			m_length = re.search('^Length: (\d+)', line)
			m_name1 = re.search('^Saving to: .(.+).$', line)
			m_name2 = re.search('^Server file no newer than local file .(.+). -- not retrieving\.$', line)
			m_percent = re.search('^\s{0,2}(\d+)(\.\d+)?%', line)
			m_progress = re.search('^\s*\[', line)
			#m_speed = re.search('(\d+(?:\.\d+)?)K/s  eta (\S+)', line)
			m_kilodots = re.search('^\s*(\d+)K\s+([., ]*)', line)
			m_completed = re.search(' saved \S+$', line)
			
			if m_length:
				self.size = int(m_length.group(1))
			if m_name1:
				self.outfile = m_name1.group(1)
				refresh = True
			if m_name2:
				self.outfile = m_name2.group(1)
				refresh = True
			if m_percent:
				self.percent = int(m_percent.group(1))
				self['status'] = S_DL
				refresh = True
			if m_progress:
				pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_kilodots:
				if self.size is not None:
					kilo = int(m_kilodots.group(1))
					dots = len(''.join(m_kilodots.group(2).split()))
					self.percent = int((kilo + dots) * 1024 * 100 / self.size)
				else:
					pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_completed:
				self.completed = True
				self['status'] = S_SAVED
				refresh = True
			if self.lastline != line:
				refresh = True
			self.lastline = line
			if refresh:
				refresh_download_state(self)
		fh.close()
		self.running = False
		self['status'] = S_ERR
		self['pid'] = None
		refresh_download_state(self)
	def stop(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], signal.SIGTERM)
				self['status'] = S_STOP
			except OSError, e:
				if e.errno != os.errno.ESRCH:
					raise e


def win_main_show():
	btn_remove.hide()
	# TODO load cached downloads from logs
	if args.URL:
		# TODO open new download window and set urls
		pass

def act_quit():
	if any(DownLoadList[it][COL_DLOBJ].running for it in iter_downloadlist()) and not question(_("Running downloads will continue in the background.\nQuit anyway?"), yes=gtk.STOCK_QUIT, default=gtk.RESPONSE_NO):
		return True
	gtk.main_quit()
	return False

def next_logfile():
	n = len(os.listdir(CacheFolder))
	f = 'gwget.' + str(n)
	while os.path.exists(os.path.join(CacheFolder, f)) or any(f == os.path.basename(DownLoadList[it][COL_DLOBJ].logfile or '') for it in iter_downloadlist()):
		n += 1
		f = 'gwget.' + str(n)
	return os.path.join(CacheFolder, f)

class iter_downloadlist(object):
	def __init__(self):
		self.model = DownLoadList
		self.cur_iter = self.model.get_iter_first()
	def __iter__(self):
		return self
	def next(self):
		if self.cur_iter is None:
			raise StopIteration
		ret = self.cur_iter
		self.cur_iter = self.model.iter_next(self.cur_iter)
		return ret
	def __del__(self):
		pass

def refresh_download_state(dlobj):
	if threading.currentThread().name != 'MainThread':
		gtk.threads_enter()
	for it in iter_downloadlist():
		row = DownLoadList[it]
		dl = row[COL_DLOBJ]
		if dl == dlobj:
			if dl.outfile is not None:
				row[COL_NAME] = os.path.basename(dl.outfile)
			if dl.percent >= 0:
				row[COL_PULSE] = -1
				row[COL_PERCENT] = dl.percent
				row[COL_PRCSTR] = str(dl.percent) + '%'
			else:
				if dl.running:
					try:
						row[COL_PULSE] += 2
					except TypeError:
						row[COL_PULSE] = 1
				else:
					if dl.completed:
						row[COL_PULSE] = gobject.constants.G_MAXINT
					else:
						row[COL_PULSE] = 0
				row[COL_PRCSTR] = ''
			row[COL_STATUS_ICON] = StatusIcon[dl['status']]
			row[COL_STATUS] = _(Status[dl['status']])
			row[COL_MESSAGE] = '<tt>' + glib.markup_escape_text(dl.lastline) + '</tt>'
			
			# if the current download is selected, then refresh toolbuttons sensitivity
			if main_selection.iter_is_selected(it):
				on_selection_change(main_selection)
			break
	if threading.currentThread().name != 'MainThread':
		gtk.threads_leave()

def pulse_download(pid):
	for it in iter_downloadlist():
		if DownLoadList[it][COL_DLOBJ]['pid'] == pid:
			DownLoadList[it][COL_PULSE] += 1

def start_new_download(url, params, start=True):
	dl = Download(url, params)
	it = DownLoadList.append([dl, os.path.basename(url), gtk.STOCK_FILE, None, '', 0, 0, gtk.STOCK_MEDIA_STOP, _(Status[S_QUEUE]), ''])
	if start:
		dl.start()
	return it


### Interface procedures ###

def act_new():
	p1t1.set_text('')
	# TODO clear fields
	win_newdl.show_all()
	for n in reversed(range(0, note.get_n_pages())):
		note.set_current_page(n)
	p1t1.grab_focus()

def act_start_all():
	for it in iter_downloadlist():
		dl = DownLoadList[it][COL_DLOBJ]
		if not dl.running:
			act_start(None, dl)

def act_pause_all():
	for it in iter_downloadlist():
		dl = DownLoadList[it][COL_DLOBJ]
		if dl.running:
			act_pause(None, dl)

def act_clear_completed():
	for it in iter_downloadlist():
		dl = DownLoadList[it][COL_DLOBJ]
		if dl.completed:
			act_clear_download(it, dl)

def act_options():
	pass


def act_open_file(it, dl):
	if dl.outfile is not None:
		run_detached('mimeopen-gui', [dl.outfile])

def act_open_folder(it, dl):
	for n in range(len(dl.params)):
		if dl.params[n] == '--directory-prefix':
			run_detached('mimeopen-gui', [dl.params[n+1]])
			break

def act_start(it, dl):
	dl.start()

def act_refetch(it, dl):
	if dl.outfile is not None:
		delete(dl.outfile)
	dl.start()

def act_pause(it, dl):
	dl.stop()

def act_remove_download(it, dl, force=False):
	if not dl.running and dl.outfile is not None:
		if not dl.completed or force or question(_("Would you like to <b>delete completed</b> file?"), yes=gtk.STOCK_DELETE, default=gtk.RESPONSE_NO):
			delete(dl.outfile)

def act_clear_download(it, dl):
	if not dl.running:
		if not dl.completed and dl.outfile is not None and os.path.exists(dl.outfile):
			try:
				if question(_("This download is not completed.\nWould you like to <b>delete partial</b> download?"), yes=gtk.STOCK_DELETE, cancelable=True, default=gtk.RESPONSE_CANCEL):
					act_remove_download(it, dl, force=True)
			except DialogCancel:
				return
		if dl.logfile is not None:
			delete(dl.logfile)
		del DownLoadList[it]

def act_show_log(it, dl):
	os.system("cat %s" % dl.logfile)

def act_props(it, dl):
	print dl.__dict__



def act_on_selection(func):
	iters = []
	for itpath in main_selection.get_selected_rows()[1]:
		iters.append(DownLoadList.get_iter(itpath))
	for it in iters:
		func(it, DownLoadList[it][COL_DLOBJ])

def on_selection_change(selection):
	iters = map(lambda p: DownLoadList.get_iter(p), selection.get_selected_rows()[1])
	dls = map(lambda it: DownLoadList[it][COL_DLOBJ], iters)
	num = len(iters)
	btn_resume.set_sensitive(num>0 and all(not dl.running and not dl.completed for dl in dls))
	btn_pause.set_sensitive(num>0 and all(dl.running for dl in dls))
	btn_remove.set_sensitive(num>0 and all(dl.outfile is not None and not dl.running for dl in dls))
	btn_clear.set_sensitive(num>0 and all(not dl.running for dl in dls))
	btn_props.set_sensitive(num == 1)

def on_context_menu(menuitem, function):
	it = ContextMenu.get_data('iterator')
	dl = DownLoadList[it][COL_DLOBJ]
	function(it, dl)
	return True

def on_treeview_click(tree, event):
	if any(event.state & getattr(gtk.gdk, mask+'_MASK') for mask in ['CONTROL','SHIFT','MOD4','MOD5','META']):
		return False
	pathinfo = main_list.get_path_at_pos(int(event.x), int(event.y))
	if pathinfo is not None:
		path, col, cellx, celly = pathinfo
		it = DownLoadList.get_iter(path)
		dl = DownLoadList[it][COL_DLOBJ]
		if event.type == gtk.gdk.BUTTON_PRESS and event.button == 3:
			ContextMenu.set_data('iterator', it)
			cmi_open.set_sensitive(dl.completed)
			cmi_remove.set_sensitive(dl.outfile is not None and not dl.running and os.path.exists(dl.outfile))
			cmi_refetch.set_sensitive(not dl.running)
			cmi_resume.set_sensitive(not dl.running and not dl.completed)
			cmi_pause.set_sensitive(dl.running)
			cmi_clear.set_sensitive(not dl.running)
			ContextMenu.popup(None, None, None, event.button, event.time)
			return True
		elif event.type == gtk.gdk._2BUTTON_PRESS and event.button == 1:
			act_open_file(it, dl)
			return True
	return False


## New download window
def new_download(start=True, open=False):
	params = {}
	for flag, wdg, getter in ParamWidgets:
		data = wdg.get_text()
		if getter is not None:
			data = getter(data)
		if data:
			params[flag] = data
	if open:
		params['on_complete'] = 'mimeopen-gui %s'
	
	main_selection.unselect_all()
	uniq = {}
	for url in p1t1.get_text().split():
		if not uniq.has_key(url):
			uniq[url] = it = start_new_download(url, params, start=start)
			main_selection.select_iter(it)
	win_newdl.hide()



### Main ###

PROGNAME = 'gwget'
_ = gettext.gettext
class Var(object): pass
Var.LastFolder = os.getcwd()
XATTR_CHARSET = 'user.mime_encoding'
CacheFolder = os.path.join(os.environ['HOME'], '.cache', 'gwget')
COL_DLOBJ, COL_NAME, COL_FILE_ICON, COL_PXB, COL_PRCSTR, COL_PERCENT, COL_PULSE, COL_STATUS_ICON, COL_STATUS, COL_MESSAGE = range(10)
S_QUEUE, S_INIT, S_DL, S_SAVED, S_ERR, S_STOP = range(6)
Status = {
	S_QUEUE: "Queued",
	S_INIT: "Init",
	S_DL: "Download",
	S_SAVED: "Saved",
	S_ERR: "Failed",
	S_STOP: "Paused",
}
StatusIcon = {
	S_QUEUE: gtk.STOCK_MEDIA_STOP,
	S_INIT: 'media-seek-forward',
	S_DL: 'media-playback-start',
	S_SAVED: gtk.STOCK_APPLY,
	S_ERR: gtk.STOCK_NO,
	S_STOP: gtk.STOCK_MEDIA_PAUSE,
}
ParamWidgets = []

argparser = argparse.ArgumentParser()
argparser.add_argument('--stdin', help=_(""))
argparser.add_argument('--cookie', metavar='NAME=STRING;NAME=STRING;...', help=_(""))
argparser.add_argument('--cookie-jar', metavar='FILE', help=_(""))
argparser.add_argument('--auth', metavar='USER:PASS', help=_(""))
argparser.add_argument('--proxy', metavar='URL', help=_(""))
argparser.add_argument('--referer', metavar='URL', help=_(""))
argparser.add_argument('--agent', metavar='STRING', help=_(""))
argparser.add_argument('URL', nargs='*', help=_(""))
args = argparser.parse_args()


gtk.gdk.threads_init()
mkdir(CacheFolder)


### Build GUI ###

## Main window

# Declare main window's widgets
win_main = gtk.Window()
box_main = gtk.VBox()
main_toolbar = gtk.Toolbar()
scroller = gtk.ScrolledWindow()
DownLoadList = gtk.ListStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, str, float, int, str, str, str)
main_list = gtk.TreeView(DownLoadList)
main_selection = main_list.get_selection()
ContextMenu = gtk.Menu()
cmi_open = StockMenuItem(None, gtk.STOCK_OPEN)
cmi_folder = StockMenuItem(_("Open Folder"), gtk.STOCK_DIRECTORY)
cmi_remove = StockMenuItem(_("Delete File"), gtk.STOCK_DELETE)
cmi_refetch = StockMenuItem(_("Re-download"), gtk.STOCK_REFRESH)
cmi_resume = StockMenuItem(_("Resume"), gtk.STOCK_MEDIA_PLAY)
cmi_pause = StockMenuItem(_("Pause"), gtk.STOCK_MEDIA_PAUSE)
cmi_clear = StockMenuItem(_("Clear"), gtk.STOCK_CLEAR)
cmi_log = StockMenuItem(_("Show Log"), gtk.STOCK_INFO)
cmi_props = StockMenuItem(None, gtk.STOCK_PROPERTIES)


# Configure main window's widgets
win_main.set_default_size(950, 450)
start_evt = win_main.connect('map-event', lambda w,e: (win_main.disconnect(start_evt), win_main_show()))
win_main.connect('delete-event', lambda w,e: act_quit())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_new())
add_key_binding(win_main, '<Control>p', lambda a,b,c,d: act_pause_all())
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_options())

toolbuttons = [
	(None, gtk.STOCK_NEW, None, act_new),
	(_("Resume All"), gtk.STOCK_MEDIA_PLAY, None, act_start_all),
	(_("Pause All"), gtk.STOCK_MEDIA_PAUSE, None, act_pause_all),
	(_("Clear Completed"), gtk.STOCK_CLEAR, None, act_clear_completed),
	(None, None, None, 'separator'),
	(_("Resume"), gtk.STOCK_MEDIA_PLAY, None, (act_on_selection, act_start)),
	(_("Pause"), gtk.STOCK_MEDIA_PAUSE, None, (act_on_selection, act_pause)),
	(_("Delete File"), gtk.STOCK_DELETE, None, (act_on_selection, act_remove_download)),
	(_("Clear"), gtk.STOCK_CLEAR, None, (act_on_selection, act_clear_download)),
	(None, gtk.STOCK_PROPERTIES, None, (act_on_selection, act_props)),
	(None, None, None, 'space'),
	(None, gtk.STOCK_PREFERENCES, None, act_options),
	(None, gtk.STOCK_QUIT, None, act_quit),
]
x, x, x, x, x_, btn_resume, btn_pause, btn_remove, btn_clear, btn_props, x_, x, x \
= load_toolitems(main_toolbar, toolbuttons)
on_selection_change(main_selection)


tvc = gtk.TreeViewColumn(_("Filename"))
tvc.set_resizable(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_NAME)
tvc.add_attribute(cr_pix, 'icon-name', COL_FILE_ICON)
tvc.add_attribute(cr_pix, 'pixbuf', COL_PXB)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Progress"))
tvc.set_resizable(True)
cr_prc = gtk.CellRendererProgress()
tvc.pack_start(cr_prc, True)
tvc.add_attribute(cr_prc, 'text', COL_PRCSTR)
tvc.add_attribute(cr_prc, 'value', COL_PERCENT)
tvc.add_attribute(cr_prc, 'pulse', COL_PULSE)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Status"))
tvc.set_resizable(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_STATUS)
tvc.add_attribute(cr_pix, 'icon-name', COL_STATUS_ICON)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Message"))
tvc.set_resizable(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'markup', COL_MESSAGE)
main_list.append_column(tvc)

main_list.set_rules_hint(True)
main_list.set_headers_clickable(True)
main_list.set_reorderable(True)
main_list.connect('button-press-event', on_treeview_click)
main_selection.set_mode(gtk.SELECTION_MULTIPLE)
main_selection.connect('changed', on_selection_change)
cmi_open.connect('activate', on_context_menu, act_open_file)
cmi_folder.connect('activate', on_context_menu, act_open_folder)
cmi_remove.connect('activate', on_context_menu, act_remove_download)
cmi_refetch.connect('activate', on_context_menu, act_refetch)
cmi_resume.connect('activate', on_context_menu, act_start)
cmi_pause.connect('activate', on_context_menu, act_pause)
cmi_clear.connect('activate', on_context_menu, act_clear_download)
cmi_log.connect('activate', on_context_menu, act_show_log)
cmi_props.connect('activate', on_context_menu, act_props)


# Pack main window's widgets
win_main.add(box_main)
box_main.pack_start(main_toolbar, 0, 1)
box_main.pack_start(scroller, 1, 1)
scroller.add_with_viewport(main_list)
scroller.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
ContextMenu.append(cmi_open)
ContextMenu.append(cmi_folder)
ContextMenu.append(cmi_remove)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_refetch)
ContextMenu.append(cmi_resume)
ContextMenu.append(cmi_pause)
ContextMenu.append(cmi_clear)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_log)
ContextMenu.append(cmi_props)
ContextMenu.show_all()


## New Download window

# Declare new download window's widgets
win_newdl = gtk.Window()
box_newdl = gtk.VBox()
note = gtk.Notebook()
page1 = gtk.VBox()
p1x1 = gtk.HBox()
p1l1 = gtk.Label(_("URLs"))
p1t1 = ScrolledTextView()
p1c1 = FileChooserEntry(label=_("Select a Folder"), init=Var.LastFolder, action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
page2 = gtk.VBox()
p2x1 = gtk.VBox()
p2c1 = FileChooserEntry(label=_("Cookie file"), action=gtk.FILE_CHOOSER_ACTION_OPEN)
p2l1 = gtk.Label(_("Type custom Cookies per line in NAME=VALUE format:"))
p2t1 = ScrolledTextView()
page3 = gtk.VBox()
p3l1 = gtk.Label(_("Type POST parameters per line in NAME=VALUE format:\nURL encoding is not necessary"))
p3t1 = ScrolledTextView()
page4 = gtk.VBox()
p4x1 = gtk.HBox(spacing=2)
p4l1a = gtk.Label(_("Attempts"))
p4a1 = gtk.Adjustment(value=1, lower=0, upper=gobject.constants.G_MAXINT, step_incr=1, page_incr=10)
p4s1 = gtk.SpinButton(p4a1)
p4l1b = gtk.Label()
p4e2 = LabelledEntry(label=_("Username"))
p4e3 = LabelledEntry(label=_("Password"))
p4e4 = LabelledEntry(label=_("Proxy URL"))
p4e5 = LabelledEntry(label=_("Referer"))
p4e6 = LabelledEntry(label=_("User Agent"))
p4x2 = gtk.HBox(spacing=2)
p4l2a = gtk.Label(_("Bandwidth limit"))
p4a2 = gtk.Adjustment(value=0, lower=0, upper=gobject.constants.G_MAXINT, step_incr=1, page_incr=10)
p4s2 = gtk.SpinButton(p4a2)
p4l2b = gtk.Label()
p4e7 = LabelledEntry(label=_("Custom wget(1) options"))
p4e8 = LabelledEntry(label=_("Run on complete"))
btns_newdl = gtk.HBox(homogeneous=True)
btn_new_save = StockButton(label=_("Download"), stock=gtk.STOCK_SAVE)
btn_new_open = StockButton(stock=gtk.STOCK_OPEN)
btn_new_queue = StockButton(label=_("Queue"), stock=gtk.STOCK_ADD)
btn_new_no = StockButton(stock=gtk.STOCK_CANCEL)

# Configure new download window's widgets
win_newdl.set_transient_for(win_main)
win_newdl.set_modal(True)
win_newdl.connect('delete-event', lambda w,e: w.hide() or True)
for label in p1l1, p2l1, p3l1, p4l1a, p4l1b:
	label.set_alignment(0, 0)
	label.set_padding(4, 5)
for spinner in p4s1, p4s2:
	spinner.set_numeric(True)
	spinner.set_alignment(1.0)
p4l1b.set_markup(_("<small><i>(0 = infinite)</i></small>"))
p4l2b.set_markup(_("kB/s <small><i>(0 = unlimited)</i></small>"))
p4e3.set_visibility(False)
btn_new_save.connect('clicked', lambda b: new_download())
btn_new_open.connect('clicked', lambda b: new_download(open=True))
btn_new_queue.connect('clicked', lambda b: new_download(start=False))
btn_new_no.connect('clicked', lambda b: win_newdl.hide() or True)

ParamWidgets.append(('--directory-prefix', p1c1, None))
ParamWidgets.append(('--load-cookies', p2c1, None))
ParamWidgets.append(('--header', p2t1, lambda x: map(lambda k: 'Cookie: ' + k, filter(lambda k: len(k), x.split('\n'))) ))
ParamWidgets.append(('--post-data', p3t1, lambda x: urlencode(dict(map(lambda p: (p if p.find('=')>-1 else p+'=').split('=', 1), filter(lambda p: len(p), x.split('\n'))))) ))
ParamWidgets.append(('--tries', p4s1, None))
ParamWidgets.append(('--user', p4e2, None))
ParamWidgets.append(('--password', p4e3, None))
ParamWidgets.append(('proxy', p4e4, None))
ParamWidgets.append(('--referer', p4e5, None))
ParamWidgets.append(('--user-agent', p4e6, None))
ParamWidgets.append(('--limit-rate', p4s2, lambda x: x+'k' ))
ParamWidgets.append(('', p4e7, lambda x: x.split() ))
ParamWidgets.append(('on_complete', p4e8, None))

# Pack new download window's widgets
win_newdl.add(box_newdl)
box_newdl.pack_start(note, 1, 1)
note.append_page(page1, gtk.Label(_("Basic")))
page1.pack_start(p1x1, 1, 1)
p1x1.pack_start(p1l1, 0, 1)
p1x1.pack_start(p1t1, 1, 1)
page1.pack_start(p1c1, 0, 1)
note.append_page(page2, gtk.Label(_("Cookies")))
page2.pack_start(p2x1, 1, 1)
p2x1.pack_start(p2c1, 0, 1)
p2x1.pack_start(p2l1, 0, 1)
p2x1.pack_start(p2t1, 1, 1)
note.append_page(page3, gtk.Label(_("POST")))
page3.pack_start(p3l1, 0, 0)
page3.pack_start(p3t1, 1, 1)
note.append_page(page4, gtk.Label(_("Advanced")))
page4.pack_start(p4x1, 0, 1)
p4x1.pack_start(p4l1a, 0, 1)
p4x1.pack_start(p4s1, 0, 1)
p4x1.pack_start(p4l1b, 0, 1)
page4.pack_start(p4e2, 0, 1)
page4.pack_start(p4e3, 0, 1)
page4.pack_start(p4e4, 0, 1)
page4.pack_start(p4e5, 0, 1)
page4.pack_start(p4e6, 0, 1)
page4.pack_start(p4x2, 0, 1)
p4x2.pack_start(p4l2a, 0, 1)
p4x2.pack_start(p4s2, 0, 1)
p4x2.pack_start(p4l2b, 0, 1)
page4.pack_start(p4e7, 0, 1)
page4.pack_start(p4e8, 0, 1)
box_newdl.pack_start(btns_newdl, 0, 1)
btns_newdl.pack_start(btn_new_save, 0, 0)
btns_newdl.pack_start(btn_new_open, 0, 0)
btns_newdl.pack_start(btn_new_queue, 0, 0)
btns_newdl.pack_start(btn_new_no, 0, 0)



win_main.show_all()
gtk.main()
