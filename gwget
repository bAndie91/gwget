#!/usr/bin/env python

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import re
import argparse
import xattr
import threading
import time
import functools


def act_quit():
	gtk.main_quit()
	return False

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = '%s (#%d)\n%s' % (e.strerror, e.errno, e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

class DialogCancel(Exception):
	pass

def question(msg, yes=None, parent=None, cancelable=False):
	dlg = gtk.MessageDialog(parent, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_NONE)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if yes is None:
		dlg.add_buttons(gtk.STOCK_YES, gtk.RESPONSE_YES)
	else:
		if type(yes) in [type(()), type([])]:
			btn_yes = StockButton(label=yes[0], stock=yes[1])
			dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
			btn_yes.show()
		else:
			dlg.add_buttons(yes, gtk.RESPONSE_YES)
	dlg.add_buttons(gtk.STOCK_NO, gtk.RESPONSE_NO)
	if cancelable:
		dlg.add_buttons(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		add_key_binding(dlg, 'Escape', lambda a,b,c,d: dlg.response(gtk.RESPONSE_CANCEL) or True)
	resp = dlg.run()
	dlg.destroy()
	if resp == gtk.RESPONSE_CANCEL:
		raise DialogCancel()
	return (resp == gtk.RESPONSE_YES)

def set_dialog_icon_name(dlg, icon):
	img = dlg.get_content_area().children()[0].children()[0]
	img.set_from_icon_name(icon, gtk.ICON_SIZE_DIALOG)

def create_choose_dialog(action, path=None, init=None):
	btn_accept_stock = gtk.STOCK_OPEN
	if action in [gtk.FILE_CHOOSER_ACTION_SAVE, gtk.FILE_CHOOSER_ACTION_CREATE_FOLDER]:
		btn_accept_stock = gtk.STOCK_SAVE
	dlg = gtk.FileChooserDialog(parent=None, action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	
	if action in [gtk.FILE_CHOOSER_ACTION_OPEN, gtk.FILE_CHOOSER_ACTION_SAVE] and path is not None:
		dlg.set_filename(path)
	else:
		dlg.set_current_folder(path or LastFolder)
	if init is not None:
		dlg.set_current_name(init)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	return dlg

def choose_dialog(action, path=None, init=None):
	selected = None
	dlg = create_choose_dialog(action, path=path, init=init)
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			# 'Working Dir' button
			dlg.set_current_folder(os.getcwd())
		else:
			break
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename=filename)

def choose_folder(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, folder=folder)

def choose_open_file(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN, folder=folder)

class FileChooserEntry(gtk.HBox):
	def __init__(self, label='', init='', action=gtk.FILE_CHOOSER_ACTION_OPEN):
		super(self.__class__, self).__init__(spacing=2)
		self.label = gtk.Label(label)
		self.label.set_alignment(0, 0)
		self.label.set_padding(2, 8)
		self.entry = gtk.Entry()
		self.entry.set_text(init)
		self.button = StockButton(label='', stock=gtk.STOCK_OPEN, icon_size=gtk.ICON_SIZE_MENU)
		self.button.connect('clicked', self.choose, action)
		self.pack_start(self.label, 0, 0)
		self.pack_start(self.entry, 1, 1)
		self.pack_start(self.button, 0, 0)
	def get_text(self):
		return self.entry.get_text()
	def set_text(self, text):
		return self.entry.set_text(text)
	def get_label(self):
		return self.label.get_text()
	def set_label(self, text):
		return self.label.set_text(text)
	def choose(self, btn, action):
		p = choose_dialog(action, path=self.get_text())
		if p is not None:
			self.set_text(p)

class ScrolledTextView(gtk.ScrolledWindow):
	def __init__(self):
		super(self.__class__, self).__init__()
		self.TextView = gtk.TextView()
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.set_shadow_type(gtk.SHADOW_IN)
		self.add(self.TextView)
		self.TextView.set_editable(True)
		self.TextView.set_wrap_mode(gtk.WRAP_NONE)
		self.TextView.modify_font(pango.FontDescription('monospace'))
		for attr, val in gtk.TextView.__dict__.iteritems():
			# make TextView class methods inherited
			if not hasattr(self, attr) and callable(val):
				self.__dict__[attr] = functools.partial(val, self.TextView)



def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_markup(self, markup):
		x, lbl = self.__get_children()
		lbl.set_markup(markup)

class StockMenuItem(gtk.ImageMenuItem):
	def __init__(self, label=None, stock_id=None, accel_group=None):
		gtk.ImageMenuItem.__init__(self, stock_id, accel_group)
		if label is not None:
			self.set_label(label)

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left in toolitems:
		hid = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(_(tip))
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		else:
			Lstocklabel = None
			st = gtk.stock_lookup(stock)
			if st:
				Lstocklabel = re.sub('_', '', st[1])
			if label is not None:
				Llabel = _(label)
			else:
				Llabel = Lstocklabel
			if tip is not None:
				Ltip = _(tip)
			else:
				if label is not None:
					Ltip = Llabel
				else:
					Ltip = Lstocklabel
			tbi = StockToolButton(label=Llabel, stock=stock, tooltip=Ltip)
			tbi.set_data('stock', stock)
			tbi.set_data('label', label)
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

## OS functions

def mkdir(d):
	p = os.path.dirname(d)
	if not os.path.exists(p):
		mkdir(p)
	try:
		os.mkdir(d)
	except OSError, e:
		if e.errno != os.errno.EEXIST:
			raise e

def stderr(s):
	sys.stderr.write(s)

def delete(f, warn=True):
	try:
		os.unlink(f)
	except OSError, e:
		if warn:
			stderr('%s: error %d: %s\n' % (e.filename, e.errno, e.strerror))
		if e.errno != os.errno.ENOENT:
			display_error(e)
			return False
	return True

def run_detached(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			try:
				os.execvp(cmd, args)
			except OSError:
				pass
			os._exit(127)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)


### Private methods ###

class Download(object):
	def __init__(self, url, params=[], retries=1, target_dir='.'):
		self.original_url = url
		self.params = params
		self.progress_type = 'bar:force'
		#self.progress_type = 'dot:default'
		self.retries = retries
		self.target_dir = target_dir
		self.logfile = None
		self.outfile = None
		self.Lock = threading.Lock()
		self._pid = None
		self.init()
	def init(self):
		self['status'] = S_QUEUE
		self.completed = False
		self.running = False
		self.size = None
		self.percent = -1
		self.lastline = ''
	def __getitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			self.Lock.release()
			return getattr(self, '_' + key)
		else:
			raise KeyError()
	def __setitem__(self, key, val):
		self.Lock.acquire(True)
		if key == 'status' and hasattr(self, '_status'):
			if (self._status == S_STOP and val == S_DL) or (val == S_ERR and self._status in [S_SAVED, S_STOP]):
				self.Lock.release()
				return False
		setattr(self, '_' + key, val)
		self.Lock.release()
		return True
	def __delitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			delattr(self, '_' + key)
		self.Lock.release()
	def spawn_wget(self, args=[]):
		reader, writer = os.pipe()
		pid = os.fork()
		if pid == 0:
			os.putenv('LANG', 'C')
			#os.putenv('http_proxy', )
			os.close(reader)
			os.dup2(writer, sys.stdout.fileno())
			os.dup2(writer, sys.stderr.fileno())
			sys.stdin.close()
			os.closerange(3, 255)
			os.execvp('wget', ['wget'] + args)
			os._exit(127)
		os.close(writer)
		return os.fdopen(reader, 'r')
	def start(self):
		if self['pid'] is not None:
			return
		self.init()
		refresh_download_state(None, self.iterator)
		if self.logfile is None:
			self.logfile = next_logfile()
		if not delete(self.logfile, warn=False):
			return
		
		wget_args = self.params + ['--output-file', self.logfile, '--adjust-extension', \
		  '--content-disposition', '--background', '--continue', '--tries', str(self.retries), \
		  '--directory-prefix', self.target_dir, '--verbose', '--progress', self.progress_type]
		wget_args.append(self.original_url)
		try:
			readhandle = self.spawn_wget(wget_args)
		except OSError, e:
			display_error(e)
			return
		
		self['status'] = S_INIT
		refresh_download_state(None, self.iterator)
		for line in readhandle.readlines():
			m_pid = re.search('pid (\d+)', line)
			if m_pid:
				self['pid'] = int(m_pid.group(1))
				break
		t = threading.Thread(target=self.watch_log, args=())
		t.daemon = True
		t.start()
	def wget_running(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], 0)
				return True
			except OSError:
				pass
		return False
	def watch_log(self):
		while not os.path.exists(self.logfile):
			time.sleep(1)
		self.running = True
		fh = open(self.logfile, 'r')
		linebuffer = ''
		while True:
			data = fh.readline()
			if data == '':
				if self.wget_running():
					time.sleep(0.4)
					continue
				else:
					break
			
			line = linebuffer + data
			try: rline = line[line.rindex('\r')+1:]
			except ValueError: rline = line
			if line[-1] == '\n':
				linebuffer = ''
			else:
				linebuffer = rline
			line = rline.strip()
			if line == '':
				continue
			
			refresh = False
			m_length = re.search('^Length: (\d+)', line)
			m_name1 = re.search('^Saving to: .(.+).$', line)
			m_name2 = re.search('^Server file no newer than local file .(.+). -- not retrieving\.$', line)
			m_percent = re.search('^\s{0,2}(\d+)(\.\d+)?%', line)
			m_progress = re.search('^\s*\[', line)
			#m_speed = re.search('(\d+(?:\.\d+)?)K/s  eta (\S+)', line)
			m_kilodots = re.search('^\s*(\d+)K\s+([., ]*)', line)
			m_completed = re.search(' saved \S+$', line)
			
			if m_length:
				self.size = int(m_length.group(1))
			if m_name1:
				self.outfile = m_name1.group(1)
				refresh = True
			if m_name2:
				self.outfile = m_name2.group(1)
				refresh = True
			if m_percent:
				self.percent = int(m_percent.group(1))
				self['status'] = S_DL
				refresh = True
			if m_progress:
				pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_kilodots:
				if self.size is not None:
					kilo = int(m_kilodots.group(1))
					dots = len(''.join(m_kilodots.group(2).split()))
					self.percent = int((kilo + dots) * 1024 * 100 / self.size)
				else:
					pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_completed:
				self.completed = True
				self['status'] = S_SAVED
				refresh = True
			if self.lastline != line:
				refresh = True
			self.lastline = line
			if refresh:
				refresh_download_state(self['pid'])
		fh.close()
		self.running = False
		self['status'] = S_ERR
		refresh_download_state(self['pid'])
		self['pid'] = None
	def stop(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], signal.SIGTERM)
				self['status'] = S_STOP
			except OSError, e:
				if e.errno != os.errno.ESRCH:
					raise e


def win_main_show():
	if args.URL:
		main_selection.unselect_all()
		for url in args.URL:
			# TODO set parameters
			it = start_new_download(url)
			main_selection.select_iter(it)

def next_logfile():
	n = len(os.listdir(CacheFolder))
	f = 'gwget.' + str(n)
	while os.path.exists(os.path.join(CacheFolder, f)):
		n += 1
		f = 'gwget.' + str(n)
	return os.path.join(CacheFolder, f)

class iter_downloadlist(object):
	def __init__(self, rit=False):
		self.rit = rit
	def __iter__(self):
		self.model = DownLoadList
		self.iter = self.model.get_iter_first()
		return self
	def next(self):
		if self.iter is None:
			raise StopIteration
		if self.rit:
			ret = (self.model[self.iter][COL_DLOBJ], self.iter)
		else:
			ret = self.model[self.iter][COL_DLOBJ]
		self.iter = self.model.iter_next(self.iter)
		return ret
	def __del__(self):
		pass

def refresh_download_state(pid, it0=None):
	for dl, it in iter_downloadlist(True):
		if (pid is not None and dl['pid'] == pid) or (it0 is not None and it == it0):
			row = DownLoadList[it]
			row[COL_NAME] = os.path.basename(dl.outfile or '')
			if dl.percent >= 0:
				row[COL_PULSE] = -1
				row[COL_PERCENT] = dl.percent
				row[COL_PRCSTR] = str(dl.percent) + '%'
			else:
				if dl.running:
					try:
						row[COL_PULSE] += 2
					except TypeError:
						row[COL_PULSE] = 1
				else:
					if dl.completed:
						row[COL_PULSE] = gobject.constants.G_MAXINT
					else:
						row[COL_PULSE] = 0
				row[COL_PRCSTR] = ''
			row[COL_STATUS_ICON] = StatusIcon[dl['status']]
			row[COL_STATUS] = _(Status[dl['status']])
			row[COL_MESSAGE] = '<tt>' + glib.markup_escape_text(dl.lastline) + '</tt>'
			
			# if the current download is selected, then refresh toolbuttons sensitivity
			if main_selection.iter_is_selected(it):
				gtk.threads_enter()
				on_selection_change(main_selection)
				gtk.threads_leave()
			break

def pulse_download(pid):
	for dl, it in iter_downloadlist(True):
		if dl['pid'] == pid:
			DownLoadList[it][COL_PULSE] += 1

def start_new_download(url, start=True):
	dl = Download(url)
	it = DownLoadList.append([dl, os.path.basename(url), gtk.STOCK_FILE, None, '', 0, 0, gtk.STOCK_MEDIA_STOP, _(Status[S_QUEUE]), ''])
	dl.iterator = it
	if start:
		dl.start()
	return it


### Interface procedures ###

def act_new():
	bufr_urls.set_text('')
	win_newdl.show_all()
	note.set_current_page(0)
	txv_urls.grab_focus()

def act_start_all():
	for dl in iter_downloadlist():
		if not dl.running:
			act_start(None, dl)

def act_pause_all():
	for dl in iter_downloadlist():
		if dl.running:
			act_pause(None, dl)

def act_clear_completed():
	for dl, it in iter_downloadlist(True):
		if dl.completed:
			act_clear_download(it, dl)

def act_options():
	pass


def act_open_file(it, dl):
	if dl.outfile is not None:
		run_detached('mimeopen-gui', [dl.outfile])

def act_open_folder(it, dl):
	if dl.target_dir is not None:
		run_detached('mimeopen-gui', [dl.target_dir])

def act_start(it, dl):
	dl.start()

def act_refetch(it, dl):
	if dl.outfile is not None:
		delete(dl.outfile)
	dl.start()

def act_pause(it, dl):
	dl.stop()

def act_remove_download(it, dl, force=False):
	if not dl.running and dl.outfile is not None:
		if not dl.completed or force or question(_("Would you like to <b>delete completed</b> file?"), yes=gtk.STOCK_DELETE):
			delete(dl.outfile)

def act_clear_download(it, dl):
	if not dl.running:
		if not dl.completed and dl.outfile is not None and os.path.exists(dl.outfile):
			try:
				if question(_("This download is not completed.\nWould you like to <b>delete partial</b> download?"), yes=gtk.STOCK_DELETE, cancelable=True):
					act_remove_download(it, dl, force=True)
			except DialogCancel:
				return
		delete(dl.logfile)
		del DownLoadList[it]

def act_show_log(it, dl):
	os.system("cat %s" % dl.logfile)

def act_props(it, dl):
	print dl.__dict__



def act_on_selection(func):
	iters = []
	for itpath in main_selection.get_selected_rows()[1]:
		iters.append(DownLoadList.get_iter(itpath))
	for it in iters:
		func(it, DownLoadList[it][COL_DLOBJ])

def on_selection_change(selection):
	iters = map(lambda p: DownLoadList.get_iter(p), selection.get_selected_rows()[1])
	dls = map(lambda it: DownLoadList[it][COL_DLOBJ], iters)
	num = len(iters)
	btn_resume.set_sensitive(num>0 and all(not dl.running and not dl.completed for dl in dls))
	btn_pause.set_sensitive(num>0 and all(dl.running for dl in dls))
	btn_remove.set_sensitive(num>0 and all(dl.outfile is not None and not dl.running for dl in dls))
	btn_clear.set_sensitive(num>0 and all(not dl.running for dl in dls))
	btn_props.set_sensitive(num == 1)

def on_context_menu(menuitem, function):
	it = ContextMenu.get_data('iterator')
	dl = DownLoadList[it][COL_DLOBJ]
	function(it, dl)
	return True

def on_treeview_click(tree, event):
	if any(event.state & getattr(gtk.gdk, mask+'_MASK') for mask in ['CONTROL','SHIFT','MOD4','MOD5','META']):
		return False
	pathinfo = main_list.get_path_at_pos(int(event.x), int(event.y))
	if pathinfo is not None:
		path, col, cellx, celly = pathinfo
		it = DownLoadList.get_iter(path)
		dl = DownLoadList[it][COL_DLOBJ]
		if event.type == gtk.gdk.BUTTON_PRESS and event.button == 3:
			ContextMenu.set_data('iterator', it)
			cmi_open.set_sensitive(dl.completed)
			cmi_remove.set_sensitive(dl.outfile is not None and not dl.running and os.path.exists(dl.outfile))
			cmi_refetch.set_sensitive(not dl.running)
			cmi_resume.set_sensitive(not dl.running and not dl.completed)
			cmi_pause.set_sensitive(dl.running)
			cmi_clear.set_sensitive(not dl.running)
			ContextMenu.popup(None, None, None, event.button, event.time)
			return True
		elif event.type == gtk.gdk._2BUTTON_PRESS and event.button == 1:
			act_open_file(it, dl)
			return True
	return False


## New download window
def act_select_target_folder(x):
	f = choose_folder(ent_dir.get_text())
	if f is not None:
		ent_dir.set_text(f)

def new_download(start=True):
	main_selection.unselect_all()
	uniq = {}
	for url in bufr_urls.get_text(bufr_urls.get_start_iter(), bufr_urls.get_end_iter(), True).split():
		if not uniq.has_key(url):
			# TODO parameters
			uniq[url] = it = start_new_download(url, start=start)
			main_selection.select_iter(it)
	win_newdl.hide()



### Main ###

PROGNAME = 'gwget'
_ = gettext.gettext
LastFolder = os.getcwd()
XATTR_CHARSET = 'user.mime_encoding'
CacheFolder = os.path.join(os.environ['HOME'], '.cache', 'gwget')
S_QUEUE, S_INIT, S_DL, S_SAVED, S_ERR, S_STOP = range(6)
Status = {
	S_QUEUE: "Queued",
	S_INIT: "Init",
	S_DL: "Download",
	S_SAVED: "Saved",
	S_ERR: "Failed",
	S_STOP: "Paused",
}
StatusIcon = {
	S_QUEUE: gtk.STOCK_MEDIA_STOP,
	S_INIT: 'media-seek-forward',
	S_DL: 'media-playback-start',
	S_SAVED: gtk.STOCK_APPLY,
	S_ERR: gtk.STOCK_NO,
	S_STOP: gtk.STOCK_MEDIA_PAUSE,
}

argparser = argparse.ArgumentParser()
argparser.add_argument('--stdin', help=_(""))
argparser.add_argument('--proxy', metavar='URL', help=_(""))
argparser.add_argument('--auth', metavar='USER:PASS', help=_(""))
argparser.add_argument('--cookie', metavar='NAME=STRING;NAME=STRING;...', help=_(""))
argparser.add_argument('--cookie-jar', metavar='FILE', help=_(""))
argparser.add_argument('--referer', metavar='URL', help=_(""))
argparser.add_argument('--agent', metavar='STRING', help=_(""))
argparser.add_argument('URL', nargs='*', help=_(""))
args = argparser.parse_args()


gtk.gdk.threads_init()
mkdir(CacheFolder)
# TODO initiate list of downloads


### Build GUI ###

## Main window

# Declare main window's widgets
win_main = gtk.Window()
box_main = gtk.VBox()
main_toolbar = gtk.Toolbar()
scroller = gtk.ScrolledWindow()
COL_DLOBJ, COL_NAME, COL_FILE_ICON, COL_PXB, COL_PRCSTR, COL_PERCENT, COL_PULSE, COL_STATUS_ICON, COL_STATUS, COL_MESSAGE = range(10)
DownLoadList = gtk.ListStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, str, float, int, str, str, str)
main_list = gtk.TreeView(DownLoadList)
main_selection = main_list.get_selection()
ContextMenu = gtk.Menu()
cmi_open = StockMenuItem(None, gtk.STOCK_OPEN)
cmi_folder = StockMenuItem(_("Open Folder"), gtk.STOCK_DIRECTORY)
cmi_remove = StockMenuItem(_("Delete File"), gtk.STOCK_DELETE)
cmi_refetch = StockMenuItem(_("Re-download"), gtk.STOCK_REFRESH)
cmi_resume = StockMenuItem(_("Resume"), gtk.STOCK_MEDIA_PLAY)
cmi_pause = StockMenuItem(_("Pause"), gtk.STOCK_MEDIA_PAUSE)
cmi_clear = StockMenuItem(_("Clear"), gtk.STOCK_CLEAR)
cmi_log = StockMenuItem(_("Show Log"), gtk.STOCK_INFO)
cmi_props = StockMenuItem(None, gtk.STOCK_PROPERTIES)


# Configure main window's widgets
win_main.set_default_size(800, 450)
start_evt = win_main.connect('map-event', lambda w,e: (win_main.disconnect(start_evt), win_main_show()))
win_main.connect('delete-event', lambda w,e: act_quit())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_new())
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_options())

toolbuttons = [
	(None, gtk.STOCK_NEW, None, act_new),
	(_("Resume All"), gtk.STOCK_MEDIA_PLAY, None, act_start_all),
	(_("Pause All"), gtk.STOCK_MEDIA_PAUSE, None, act_pause_all),
	(_("Clear Completed"), gtk.STOCK_CLEAR, None, act_clear_completed),
	(None, None, None, 'separator'),
	(_("Resume"), gtk.STOCK_MEDIA_PLAY, None, (act_on_selection, act_start)),
	(_("Pause"), gtk.STOCK_MEDIA_PAUSE, None, (act_on_selection, act_pause)),
	(_("Delete File"), gtk.STOCK_DELETE, None, (act_on_selection, act_remove_download)),
	(_("Clear"), gtk.STOCK_CLEAR, None, (act_on_selection, act_clear_download)),
	(None, gtk.STOCK_PROPERTIES, None, (act_on_selection, act_props)),
	(None, None, None, 'space'),
	(None, gtk.STOCK_PREFERENCES, None, act_options),
	(None, gtk.STOCK_QUIT, None, act_quit),
]
x, x, x, x, x_, btn_resume, btn_pause, btn_remove, btn_clear, btn_props, x_, x, x \
= load_toolitems(main_toolbar, toolbuttons)
on_selection_change(main_selection)


tvc = gtk.TreeViewColumn(_("Filename"))
tvc.set_resizable(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_NAME)
tvc.add_attribute(cr_pix, 'icon-name', COL_FILE_ICON)
tvc.add_attribute(cr_pix, 'pixbuf', COL_PXB)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Progress"))
tvc.set_resizable(True)
cr_prc = gtk.CellRendererProgress()
tvc.pack_start(cr_prc, True)
tvc.add_attribute(cr_prc, 'text', COL_PRCSTR)
tvc.add_attribute(cr_prc, 'value', COL_PERCENT)
tvc.add_attribute(cr_prc, 'pulse', COL_PULSE)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Status"))
tvc.set_resizable(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_STATUS)
tvc.add_attribute(cr_pix, 'icon-name', COL_STATUS_ICON)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Message"))
tvc.set_resizable(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'markup', COL_MESSAGE)
main_list.append_column(tvc)

main_list.set_rules_hint(True)
main_list.set_headers_clickable(True)
main_list.set_reorderable(True)
main_list.connect('button-press-event', on_treeview_click)
main_selection.set_mode(gtk.SELECTION_MULTIPLE)
main_selection.connect('changed', on_selection_change)
cmi_open.connect('activate', on_context_menu, act_open_file)
cmi_folder.connect('activate', on_context_menu, act_open_folder)
cmi_remove.connect('activate', on_context_menu, act_remove_download)
cmi_refetch.connect('activate', on_context_menu, act_refetch)
cmi_resume.connect('activate', on_context_menu, act_start)
cmi_pause.connect('activate', on_context_menu, act_pause)
cmi_clear.connect('activate', on_context_menu, act_clear_download)
cmi_log.connect('activate', on_context_menu, act_show_log)
cmi_props.connect('activate', on_context_menu, act_props)


# Pack main window's widgets
win_main.add(box_main)
box_main.pack_start(main_toolbar, 0, 1)
box_main.pack_start(scroller, 1, 1)
scroller.add_with_viewport(main_list)
scroller.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
ContextMenu.append(cmi_open)
ContextMenu.append(cmi_folder)
ContextMenu.append(cmi_remove)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_refetch)
ContextMenu.append(cmi_resume)
ContextMenu.append(cmi_pause)
ContextMenu.append(cmi_clear)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_log)
ContextMenu.append(cmi_props)
ContextMenu.show_all()


## New Download window

# Declare new download window's widgets
win_newdl = gtk.Window()
box_newdl = gtk.VBox()
note = gtk.Notebook()
page1 = gtk.VBox()
p1x1 = gtk.HBox()
lbl_urls = gtk.Label(_("URLs"))
txv_urls = ScrolledTextView()
bufr_urls = txv_urls.get_buffer()
p1x2 = gtk.HBox()
p1c1 = FileChooserEntry(label=_("Select a Folder"), init=LastFolder, action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
page2 = gtk.VBox()
p2x1 = gtk.VBox()
p2c1 = FileChooserEntry(label=_("Cookie file"), action=gtk.FILE_CHOOSER_ACTION_OPEN)
p2l1 = gtk.Label(_("Type custom Cookies here per line in NAME=VALUE format:"))
p2t1 = ScrolledTextView()
page3 = gtk.VBox()
p3l1 = gtk.Label(_("Type POST parameters here per line in NAME=VALUE format:\nURL encoding in not necessary."))
p3t1 = ScrolledTextView()
page4 = gtk.VBox()
btns_newdl = gtk.HBox(homogeneous=True)
btn_new_ok = StockButton(label=_("Download"), stock=gtk.STOCK_SAVE)
btn_new_queue = StockButton(label=_("Queue"), stock=gtk.STOCK_ADD)
btn_new_no = StockButton(stock=gtk.STOCK_CANCEL)

# Configure new download window's widgets
win_newdl.set_transient_for(win_main)
win_newdl.set_modal(True)
win_newdl.connect('delete-event', lambda w,e: w.hide() or True)
lbl_urls.set_alignment(0, 0)
lbl_urls.set_padding(4, 5)
p2l1.set_alignment(0, 0)
p2l1.set_padding(4, 5)
p3l1.set_alignment(0, 0)
p3l1.set_padding(4, 5)
btn_new_ok.connect('clicked', lambda b: new_download())
btn_new_queue.connect('clicked', lambda b: new_download(start=False))
btn_new_no.connect('clicked', lambda b: win_newdl.hide() or True)

# Pack new download window's widgets
win_newdl.add(box_newdl)
box_newdl.pack_start(note, 1, 1)
note.append_page(page1, gtk.Label(_("Basic")))
page1.pack_start(p1x1, 1, 1)
p1x1.pack_start(lbl_urls, 0, 1)
p1x1.pack_start(txv_urls, 1, 1)
page1.pack_start(p1x2, 0, 1)
p1x2.pack_start(p1c1, 1, 1)
note.append_page(page2, gtk.Label(_("Cookies")))
page2.pack_start(p2x1, 1, 1)
p2x1.pack_start(p2c1, 0, 1)
p2x1.pack_start(p2l1, 0, 1)
p2x1.pack_start(p2t1, 1, 1)
note.append_page(page3, gtk.Label(_("POST")))
page3.pack_start(p3l1, 0, 0)
page3.pack_start(p3t1, 1, 1)
note.append_page(page4, gtk.Label(_("Advanced")))
box_newdl.pack_start(btns_newdl, 0, 1)
btns_newdl.pack_start(btn_new_ok, 0, 0)
btns_newdl.pack_start(btn_new_queue, 0, 0)
btns_newdl.pack_start(btn_new_no, 0, 0)



win_main.show_all()
gtk.main()
