#!/usr/bin/env python2.7
# -*- coding: UTF-8 -*-

import os
import sys
import signal
import select
import fcntl
import re
import time


PROGNAME = 'gwget'
APPNAME = 'hu.uucp.gwget'

if any(flag in sys.argv for flag in ['-h', '--help']):
	print """Usage: %s [gwget options] [wget options] [URLs...]
%s options:
  --proxy-url URL
  --cookies NAME=VALUE[;NAME=VALUE[;...]]
  --cwd-prefix
  --rename-to FILENAME
  --run-on-complete COMMAND""" % (PROGNAME, PROGNAME)
	raise SystemExit(0)


import dbus
import dbus.service
import dbus.glib
import gettext
import setproctitle
import resource

import glib
import gobject
import gio
import gtk
import pango
import threading

import pickle
import traceback
import functools
import inspect

import glob
import base64
import urllib
import urlparse
try:
 import xattr
except ImportError:
 xattr = None
from mimetypes import guess_extension
import magic


# Functions and Subroutines

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def display_error(e, isPango=False, gtkErrorLevel=gtk.MESSAGE_ERROR):
	if threading.currentThread().name != 'MainThread':
		gtk.threads_enter()
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		if hasattr(e, 'filename'):
			if e.filename:
				files = e.filename
			else:
				files = '; '.join(e.filenames or [])
			files = '\n' + files
		else:
			files = ''
		text = '%s%s%s (%d)%s' % (e.message, e.message and '\n', e.strerror, e.errno, files)
	elif isinstance(e, Exception):
		text = e.message
		if hasattr(e, 'errno'):
			text += ' (%d)' % e.errno
	elif type(e) == list:
		text = '\n'.join(e)
	elif type(e) in [str, int]:
		text = str(e)
	if text is None:
		text = repr(e)
	if isinstance(e, BaseException):
		classname = e.__class__.__name__
		if not e.__class__.__module__.startswith('_'):
			classname = e.__class__.__module__ + '.' + classname
		text = classname + ':\n' + text
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtkErrorLevel, gtk.BUTTONS_OK, '' if isPango else text)
	if isPango: dlg.set_markup(text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()
	if threading.currentThread().name != 'MainThread':
		gtk.threads_leave()

class DialogCancel(Exception):
	pass

def question(msg, parent=None, yes=None, no=None, cancelable=False, default=gtk.RESPONSE_YES):
	dlg = gtk.MessageDialog(parent, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_NONE)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if yes is None:
		dlg.add_buttons(gtk.STOCK_YES, gtk.RESPONSE_YES)
	else:
		if type(yes) in [type(()), type([])]:
			btn_yes = StockButton(label=yes[0], stock=yes[1])
			dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
			btn_yes.show()
		else:
			dlg.add_buttons(yes, gtk.RESPONSE_YES)
	if no is None:
		dlg.add_buttons(gtk.STOCK_NO, gtk.RESPONSE_NO)
	else:
		if type(no) in [type(()), type([])]:
			btn_no = StockButton(label=no[0], stock=no[1])
			dlg.add_action_widget(btn_no, gtk.RESPONSE_NO)
			btn_no.show()
		else:
			dlg.add_buttons(no, gtk.RESPONSE_NO)
	if cancelable:
		dlg.add_buttons(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		add_key_binding(dlg, 'Escape', lambda a,b,c,d: dlg.response(gtk.RESPONSE_CANCEL) or True)
	dlg.set_default_response(default)
	resp = dlg.run()
	dlg.destroy()
	if resp == gtk.RESPONSE_CANCEL:
		raise DialogCancel()
	return (resp == gtk.RESPONSE_YES)

def set_dialog_icon_name(dlg, icon):
	img = dlg.get_content_area().children()[0].children()[0]
	img.set_from_icon_name(icon, gtk.ICON_SIZE_DIALOG)

def create_choose_dialog(action, path=None, init=None):
	btn_accept_stock = gtk.STOCK_OPEN
	if action in [gtk.FILE_CHOOSER_ACTION_SAVE, gtk.FILE_CHOOSER_ACTION_CREATE_FOLDER]:
		btn_accept_stock = gtk.STOCK_SAVE
	dlg = gtk.FileChooserDialog(parent=None, action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	
	if action in [gtk.FILE_CHOOSER_ACTION_OPEN, gtk.FILE_CHOOSER_ACTION_SAVE] and path is not None:
		dlg.set_filename(path)
	else:
		dlg.set_current_folder(path or LastFolder)
	if init is not None:
		dlg.set_current_name(init)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	return dlg

def choose_dialog(action, path=None, init=None):
	selected = None
	dlg = create_choose_dialog(action, path=path, init=init)
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			# 'Working Dir' button
			dlg.set_current_folder(os.getcwd())
		else:
			break
	global LastFolder
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None, init=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename=filename, init=init)

def choose_folder(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, folder=folder)

def choose_open_file(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN, folder=folder)

class FileEntryCompletion(gtk.EntryCompletion):
	def __init__(self, entry, actiontype=gtk.FILE_CHOOSER_ACTION_OPEN):
		assert(isinstance(entry, gtk.Entry))
		super(FileEntryCompletion, self).__init__()
		self.set_popup_completion(True)
		self.set_popup_set_width(True)
		self.model = gtk.ListStore(str, str)
		self.set_model(self.model)
		self.set_text_column(1)
		self.set_match_func(self.match, 0)
		self.connect('match-selected', self.selected)
		entry.set_completion(self)
		entry.connect('changed', self.edited)
		self.actiontype = actiontype
		self.entry = entry
	def edited(self, entry):
		olddir = entry.get_data('saved-dirname')
		curdir = os.path.dirname(entry.get_text())
		if olddir != curdir:
			entry.set_data('saved-dirname', curdir)
			self.model.clear()
			try:
				for f in sorted(os.listdir(curdir)):
					p = os.path.join(curdir, f)
					if os.path.isdir(p):
						p += '/'
						f += '/'
					elif self.actiontype in [gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, gtk.FILE_CHOOSER_ACTION_CREATE_FOLDER]:
						continue
					self.model.append([p, f])
			except OSError:
				entry.set_data('saved-dirname', None)
	def match(self, compl, key, itr, keycol):
		key = self.entry.get_text()
		text = self.model.get_value(itr, keycol)
		if text is not None:
			return self.model.get_value(itr, keycol).startswith(key)
		return False
	def selected(self, compl, model, itr):
		self.entry.set_text(model.get_value(itr, 0))
		self.entry.select_region(-1, -1)
		return True

class FileChooserEntry(gtk.HBox):
	def __init__(self, label='', path='', action=gtk.FILE_CHOOSER_ACTION_OPEN):
		super(FileChooserEntry, self).__init__(spacing=2)
		self.Label = gtk.Label(label)
		self.Label.set_alignment(0, 0)
		self.Label.set_padding(2, 8)
		self.Entry = gtk.Entry()
		self.Entry.set_text(path)
		self.pathcompleter = FileEntryCompletion(self.Entry, action)
		self.Button = StockButton(label='', stock=gtk.STOCK_OPEN, icon_size=gtk.ICON_SIZE_MENU)
		self.Button.connect('clicked', self.choose, action)
		self.pack_start(self.Label, 0, 0)
		self.pack_start(self.Entry, 1, 1)
		self.MenuBtn = gtk.MenuToolButton(None, None)
		self.MenuBtn.children()[0].remove(self.MenuBtn.children()[0].children()[0])
		self.pack_start(self.MenuBtn, 0, 0)
		self.pack_start(self.Button, 0, 0)
	def get_text(self):
		return self.Entry.get_text()
	def set_text(self, text):
		ent = self.Entry
		ent.set_text(text)
		ent.select_region(-1, -1)
	def get_label(self):
		return self.Label.get_text()
	def set_label(self, text):
		return self.Label.set_text(text)
	def choose(self, btn, action):
		p = choose_dialog(action, path=self.Entry.get_text())
		if p is not None:
			self.set_text(p)
	def set_history(self, items):
		historymenu = self.MenuBtn.get_menu()
		if historymenu is None:
			historymenu = gtk.Menu()
			self.MenuBtn.set_menu(historymenu)
		for menuitem in historymenu.get_children():
			historymenu.remove(menuitem)
		for label in items:
			menuitem = gtk.MenuItem(label, use_underline=False)
			menuitem.connect('activate', lambda mi: self.set_text(mi.get_label()))
			historymenu.append(menuitem)
		historymenu.show_all()

class ScrolledTextView(gtk.ScrolledWindow):
	def __init__(self):
		super(ScrolledTextView, self).__init__()
		self.TextView = gtk.TextView()
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.set_shadow_type(gtk.SHADOW_IN)
		self.add(self.TextView)
		self.TextView.set_editable(True)
		self.TextView.set_accepts_tab(False)
		self.TextView.set_wrap_mode(gtk.WRAP_NONE)
		self.TextView.modify_font(pango.FontDescription('monospace'))
		for attr, val in gtk.TextView.__dict__.iteritems():
			# make TextView class methods inherited
			if not attr.startswith('_') and not hasattr(self, attr) and callable(val):
				self.__dict__[attr] = functools.partial(val, self.TextView)
	def get_text(self):
		bufr = self.TextView.get_buffer()
		return bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True)
	def set_text(self, text):
		bufr = self.TextView.get_buffer()
		return bufr.set_text(text)
	def grab_focus(self):
		return self.TextView.grab_focus()
	def get_textview(self):
		return self.TextView

class LabelledEntry(gtk.HBox):
	def __init__(self, label='', markup=None, tooltip=None, spacing=2):
		super(LabelledEntry, self).__init__(spacing=spacing)
		self.Label = gtk.Label(label)
		self.Entry = gtk.Entry()
		self.Label.set_alignment(0, 0)
		self.Label.set_padding(4, 5)
		if markup is not None:
			self.Label.set_markup(markup)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
		self.pack_start(self.Label, 0, 1)
		self.pack_start(self.Entry, 1, 1)
		for cname in 'Entry', 'Label':
			for attr, val in getattr(gtk, cname).__dict__.iteritems():
				if not attr.startswith('_') and not hasattr(self, attr) and callable(val):
					self.__dict__[attr] = functools.partial(val, getattr(self, cname))


def act_button(func):
	if type(func) != tuple:
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None, tooltip=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(StockButton, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class BaseStockToolButton(gtk.ToolItem):
	def __init__(self, label=None, stock=None, tooltip=None, **kv):
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True

class StockToolButton(gtk.ToolButton, BaseStockToolButton):
	def __init__(self, **kv):
		super(StockToolButton, self).__init__(gtk.STOCK_MISSING_IMAGE)
		BaseStockToolButton.__init__(self, **kv)

class StockMenuToolButton(gtk.MenuToolButton, BaseStockToolButton):
	def __init__(self, **kv):
		super(StockMenuToolButton, self).__init__(gtk.STOCK_MISSING_IMAGE)
		BaseStockToolButton.__init__(self, **kv)
		menu = gtk.Menu()
		self.set_menu(menu)
		if kv.has_key('menuitems'):
			for mi in kv['menuitems']:
				if type(mi) is tuple:
					p = {}
					p['stock_id'], p['label'], p['callback'] = mi
					mi = StockMenuItem(**p)
				menu.append(mi)
		menu.show_all()

class StockMenuItem(gtk.ImageMenuItem):
	def __init__(self, label=None, stock_id=None, accel_group=None, callback=None):
		gtk.ImageMenuItem.__init__(self, stock_id, accel_group)
		if stock_id not in gtk.stock_list_ids():
			SetAnyIcon(stock_id, self)
		if label is not None:
			self.set_label(label)
		if callback is not None:
			self.connect('activate', callback)

def SetAnyIcon(name, widget):
	size = gtk.ICON_SIZE_MENU
	def find_path(name):
		dit = gtk.icon_theme_get_default()
		for d1 in dit.get_search_path():
			for d2 in ['hicolor', 'locolor']:
				sizedirs = ['16x16', 'scalable']
				try:
					sizedirs.extend(os.listdir(os.path.join(d1,d2)))
				except OSError:
					continue
				for d3 in sizedirs:
					for ext in ['png', 'xpm', 'svg']:
						p = os.path.join(d1,d2,d3,name+'.'+ext)
						if os.path.exists(p):
							return p
		raise Exception("Icon not found: '%s'" % name)
	
	if name in gtk.stock_list_ids():
		aux = gtk.ImageMenuItem(stock_id=name)
		img = aux.get_image()
	else:
		dit = gtk.icon_theme_get_default()
		img = gtk.Image()
		if dit.has_icon(name):
			pxb = dit.load_icon(name, size, 0)
			img.set_from_pixbuf(pxb)
		else:
			try:
				iconpath = find_path(name)
				img.set_from_file(iconpath)
			except:
				pass
	widget.set_image(img)

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left in toolitems:
		hid = None
		Lstocklabel = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
		else:
			tbi = StockToolButton(stock=stock)
			st = gtk.stock_lookup(stock)
			if st: Lstocklabel = re.sub('_', '', st[1])
		
		if label is not None:
			Llabel = _(label)
		else:
			Llabel = Lstocklabel
		if tip is not None:
			Ltip = _(tip)
		else:
			if label is not None:
				Ltip = Llabel
			else:
				Ltip = Lstocklabel
		
		if Llabel is not None:
			tbi.set_label(Llabel)
		if Ltip is not None:
			tbi.set_tooltip_text(Ltip)
		if callable(fnc_left) or type(fnc_left) is tuple:
			hid = tbi.connect('clicked', on_click_button, fnc_left)
			tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

def str_accurate_at_time(ts):
	HOUR = 60 * 60
	DAY = 24 * HOUR
	WEEK = 7 * DAY
	YEAR = 365 * DAY
	
	ts0 = time.time()
	age = ts0 - ts
	then = time.localtime(ts)
	if age < YEAR:
		if age < 4 * WEEK:
			if age < DAY:
				fmt = '%H:%M'
			else:
				fmt = '%d, %a'
		else:
			fmt = '%b %d'
	else:
		fmt = '%Y %b'
	return time.strftime(fmt, then)

## OS functions

def mkdir(d):
	p = os.path.dirname(d)
	if not os.path.exists(p):
		mkdir(p)
	try:
		os.mkdir(d)
	except OSError as e:
		if e.errno != os.errno.EEXIST:
			raise e

def stderr(s):
	sys.stderr.write(s)

def delete(f, warn=True):
	try:
		os.unlink(f)
	except OSError as e:
		if warn:
			stderr('%s: error %d: %s\n' % (e.filename, e.errno, e.strerror))
		if e.errno != os.errno.ENOENT:
			display_error(e)
			return False
	return True

def relative_path(target, start=None):
	if start is None:
		start = os.getcwd()
	return os.path.relpath(target, os.path.realpath(start))

class PropertyStore(object):
	pass

class ShellCommandException(Exception):
	pass

def run_synchronous(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	outreader, outwriter = os.pipe()
	errreader, errwriter = os.pipe()
	pid = os.fork()
	if pid == 0:
		os.close(outreader)
		os.close(errreader)
		os.dup2(outwriter, sys.stdout.fileno())
		os.dup2(errwriter, sys.stderr.fileno())
		sys.stdin.close()
		os.closerange(3, OSMaxFiles)
		try: os.execvp(cmd, args)
		except OSError as e: print e.message
		os._exit(127)
	
	os.close(outwriter)
	os.close(errwriter)
	outreader = os.fdopen(outreader, 'r')
	errreader = os.fdopen(errreader, 'r')
	cmd = PropertyStore()
	cmd.stdout = ''
	cmd.stderr = ''
	fds = [outreader, errreader]
	while len(fds) > 0:
		ready = select.select(fds, [], [], 2.0)
		for fd in ready[0]:
			line = fd.readline()
			if line == '':
				fd.close()
				fds.remove(fd)
			else:
				if fd == outreader:
					cmd.stdout += line
				elif fd == errreader:
					cmd.stderr += line
	x, cmd.status = os.waitpid(pid, 0)
	cmd.exitcode = cmd.status >> 8
	cmd.signal = cmd.status & 0x7F
	cmd.coredump = cmd.status & 0x80 >> 7
	#print cmd.__dict__
	return cmd

def run_detached(cmd, args, workdir=None):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 1)
		os.closerange(3, OSMaxFiles)
		pid2 = os.fork()
		if pid2 == 0:
			try:
				if workdir is not None:
					os.chdir(workdir)
				os.execvp(cmd, args)
			except OSError as e:
				sys.stderr.write(e.message + '\n')
			os._exit(127)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

class Readlines(object):
	def __init__(self, handle):
		self.handle = handle
	def __iter__(self):
		return self
	def next(self):
		s = self.handle.readline()
		if s == '':
			raise StopIteration
		return s
	def __del__(self):
		pass

def prepend_uniq(array, item):
	while item in array: array.remove(item)
	array.insert(0, item)

def convert_to_bytes(s, p='b'):
	prefix = {'b': 1, 'k': 1024, 'm': 1024**2, 'g': 1024**3, 't': 1024**4, 'p': 1024**5,}
	m = re.search('(.+?)([a-z]?)$', s, re.IGNORECASE)
	b = float(m.group(1)) * prefix[m.group(2).lower() or 'b']
	return b / prefix[p]

def set_xattrs_file(filename, attrs):
	fh = open(filename, 'r')
	try:
		set_xattrs(fh, attrs, filename)
	except:
		raise
	finally:
		fh.close()

def set_xattrs(fh, attrs, filename='-'):
	if xattr is not None:
		for attrname, attrval in attrs.iteritems():
			try:
				if attrval is None:
					try:
						xattr.removexattr(fh, attrname)
					except IOError as e:
						if e.errno != os.errno.ENODATA:
							raise e
				else:
					xattr.setxattr(fh, attrname, attrval)
			except IOError as e:
				stderr(_("Notice: can not set xattr '%s' on '%s': %s\n") % (attrname, filename, str(e)))

if not hasattr(glob, 'escape'):
	def glob_escape(s):
		for c in '[*?':
			s = s.replace(c, '['+c+']')
		return s
	glob.escape = glob_escape

def next_file_number(preglob, sufglob, n=1):
	while True:
		wildcard = preglob + str(n) + sufglob
		if not glob.glob(wildcard): break
		n += 1
	return n

def next_logfile():
	num = 1
	while True:
		num = next_file_number(glob.escape(os.path.join(CacheFolder, 'gwget-')), '.log', num)
		fpath = os.path.join(CacheFolder, 'gwget-%d.log' % (num))
		if all(fpath != dl.logfile for it, dl in iter_downloadtree(BaseTreeItem)):
			break
		num += 1
	return fpath

if hasattr(magic, 'open'):
	mime_magic = magic.open(magic.MAGIC_MIME_TYPE)
	mime_magic.load()

def guess_mime(path):
	if hasattr(magic, 'open'):
		typ = mime_magic.file(path)
	else:
		typ = magic.from_file(path, mime=True)
	if typ is not None and not re.match('[a-z0-9_+-]+/[a-z0-9_+-]+$', typ): typ = None
	return typ

### Private methods ###

class BaseTreeItem(object):
	def __init__(self):
		self.Lock = threading.Lock()
		self.pathid = None
		self.logfile = next_logfile()
	def morior(self):
		delattr(self, 'row')
		delattr(self, 'Lock')
	def resurgo(self):
		self.Lock = threading.Lock()
		# Upgrade object format by adding newer attribs.
		for attrname in 'pathid',:
			if not hasattr(self, attrname):
				stderr((_("Update object model by add missing attr '%s'") % (attrname,)) + '\n')
				setattr(self, attrname, None)
	def materialized(self):
		pass
	def configure(self, attrs, items):
		for k, v in attrs.iteritems():
			setattr(self, k, v)
	def __getitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			out = getattr(self, '_' + key)
			self.Lock.release()
			return out
		else:
			self.Lock.release()
			raise KeyError()
	def __delitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			delattr(self, '_' + key)
		self.Lock.release()
	def __setitem__(self, key, val):
		self.Lock.acquire(True)
		setattr(self, '_' + key, val)
		self.Lock.release()
		return True
	def init(self):
		self['status'] = S_QUEUE
		self.completed = False
		self.running = False
		self.size = None
		self.mime_remote = None
		self.mime_local = None
		self.charset = None
		self.percent = -1
		self.speed = 0
		self.speed_str = ''
		self.eta = -1
		self.eta_str = ''
		self.lastline = ''
	def get_dumpfile(self):
		return self.logfile[:-3] + 'obj'

class Folder(BaseTreeItem):
	def __init__(self, name):
		super(Folder, self).__init__()
		self.init()
		self.name = name
	def materialized(self):
		super(Folder, self).materialized()
		self.row[COL_FILE_ICON] = gtk.STOCK_DIRECTORY
		self.row[COL_NAME] = self.name
		self.row[COL_NAMEEDITABLE] = True
	def rename(self, newname):
		self.name = newname
		self.row[COL_NAME] = newname  # TODO segfault on reordered (DnD'ed) row

class BaseDownload(BaseTreeItem):
	def __init__(self, url, params={}):
		super(BaseDownload, self).__init__()
		self.added_ts = time.time()
		self.original_url = url
		self.params = params
		self.outfile = None
	def get_url(self):
		return self.original_url
	def mark_completed(self):
		self.completed = True
		self['status'] = S_SAVED
		self.eta = -1
		self.eta_str = ''
		if self.mime_local is None: self.set_mime_local()
		refresh_download_state(self)
		on_completed_download(self)
	def set_mime_local(self):
		self.mime_local = guess_mime(self.outfile)

class Download(BaseDownload):
	def __init__(self, url, params={}):
		super(Download, self).__init__(url, params)
		self.actual_url = None
		self.progress_type = 'bar:force'
		#self.progress_type = 'dot:default'
		self._pid = None
		self.init()
	def resurgo(self):
		super(Download, self).resurgo()
		if self.running:
			t2 = threading.Thread(target=self.watch_log, args=())
			t2.daemon = True
			t2.start()
	def __setitem__(self, key, val):
		self.Lock.acquire(True)
		if key == 'status' and hasattr(self, '_status'):
			# Do not change status S_STOP -> S_DL ; S_SAVED -> S_ERR ; S_STOP -> S_ERR ;
			if (self._status == S_STOP and val == S_DL) or (self._status in [S_SAVED, S_STOP] and val == S_ERR):
				self.Lock.release()
				return False
			if self._status == S_INIT and val == S_DL:
				# Set xAttributes when downloading just started
				try:
					setxattributes(self)
				except IOError as e:
					stderr(e.message+'\n')
		setattr(self, '_' + key, val)
		self.Lock.release()
		return True
	def get_url(self):
		return self.actual_url or self.original_url
	def spawn_wget(self, args=[]):
		reader, writer = os.pipe()
		pid = os.fork()
		if pid == 0:
			os.putenv('LANG', 'C')
			if self.params.has_key('proxy_url'):
				proxy = self.params['proxy_url']
				os.putenv('http_proxy', proxy)
				os.putenv('https_proxy', proxy)
				os.putenv('ftp_proxy', proxy)
			os.close(reader)
			os.dup2(writer, sys.stdout.fileno())
			os.dup2(writer, sys.stderr.fileno())
			sys.stdin.close()
			os.closerange(3, OSMaxFiles)
			try: os.execvp('wget', ['wget'] + args)
			except OSError as e: stderr(e.message + '\n')
			os._exit(127)
		os.close(writer)
		return os.fdopen(reader, 'r')
	def start(self):
		if self['pid'] is not None:
			return
		self.init()
		refresh_download_state(self)
		if os.path.exists(self.logfile):
			logfilename, logfiledotext = os.path.splitext(self.logfile)
			savelogfile = '%s_%d%s' % (logfilename, next_file_number(logfilename+'_', logfiledotext, 2), logfiledotext)
			try:
				os.rename(self.logfile, savelogfile)
			except OSError, e:
				# Treat this not a serious error.
				stderr(e.message + '\n')
		
		wget_args = ParamDispatcher.convert_to_wget_args(self.params)
		wget_args += ['--verbose', '--output-file', self.logfile,\
		  '--background', '--continue', '--progress', self.progress_type,\
		  '--adjust-extension', '--retry-connrefused',\
		  '--auth-no-challenge']
		wget_args.append(self.original_url)
		try:
			readhandle = self.spawn_wget(wget_args)
		except OSError as e:
			display_error(e)
			return
		
		self['status'] = S_INIT
		refresh_download_state(self)
		t1 = threading.Thread(target=self.watch_output, args=(readhandle,))
		t1.daemon = True
		t1.start()
	def wget_running(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], 0)
				return True
			except OSError:
				pass
		return False
	def watch_output(self, readhandle):
		for line in Readlines(readhandle):
			stderr(line)
			line = line.strip()
			if line != '':
				self.lastline = line
				m_pid = re.search('pid (\d+)', line)
				if m_pid:
					self['pid'] = int(m_pid.group(1))
				refresh_download_state(self)
		readhandle.close()
		if self['pid']:
			self.running = True
			t2 = threading.Thread(target=self.watch_log, args=())
			t2.daemon = True
			t2.start()
		else:
			self['status'] = S_ERR
		refresh_download_state(self)
	def watch_log(self):
		while not os.path.exists(self.logfile):
			time.sleep(1)
		fh = open(self.logfile, 'r')
		linebuffer = ''
		while True:
			data = fh.readline()
			if data == '':
				if self.wget_running():
					time.sleep(0.4)
					continue
				else:
					break
			
			line = linebuffer + data
			try: rline = line[line.rindex('\r')+1:]
			except ValueError: rline = line
			if line[-1] == '\n':
				linebuffer = ''
			else:
				linebuffer = rline
			line = rline.strip()
			if line == '':
				continue
			
			refresh = False
			m_length = re.search('^Length: (\d+)', line)
			m_mime = re.search('^Length:.*?\[(\S+?)\]', line)
			m_name1 = re.search('^Saving to: .(.+).$', line)
			m_name2 = re.search('^Server file no newer than local file .(.+). -- not retrieving\.$', line)
			m_percent = re.search('^\s{0,2}(\d+)(\.\d+)?%', line)
			m_progress = re.search('^\s*\[', line)
			m_speed = re.search('(\d+(?:\.\d+)?)(.)/s(?:\s+eta\s+(.+))?', line)
			m_kilodots = re.search('^\s*(\d+)K\s+([., ]*)', line)
			m_completed = re.search(' saved \S+$', line)
			m_redirect = re.search('^Location: (\S+)', line)
			
			if m_length:
				self.size = int(m_length.group(1))
			if m_mime:
				self.mime_remote = m_mime.group(1)
			if m_name1:
				self.outfile = m_name1.group(1).decode('string-escape')
				refresh = True
			if m_name2:
				self.outfile = m_name2.group(1).decode('string-escape')
				self.completed = True
				self.eta = -1
				self.eta_str = ''
				refresh = True
			if m_percent:
				self.percent = int(m_percent.group(1))
				self['status'] = S_DL
				refresh = True
			if m_progress:
				pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_speed:
				self.speed_str = m_speed.group(1) + m_speed.group(2) + '/s'
				self.speed = convert_to_bytes(m_speed.group(1) + m_speed.group(2))
				if m_speed.group(3) is not None:
					self.eta_str = m_speed.group(3)
					eta = 0
					for u, q in ('d', 24*60*60), ('h', 60*60), ('m', 60), ('s', 1):
						m = re.search('(\d+)'+u, m_speed.group(3))
						if m: eta += int(m.group(1)) * q
					self.eta = eta
				refresh = True
			if m_kilodots:
				if self.size is not None:
					kilo = int(m_kilodots.group(1))
					dots = len(''.join(m_kilodots.group(2).split()))
					self.percent = int((kilo + dots) * 1024 * 100 / self.size)
				else:
					pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_completed:
				self.mark_completed()
				refresh = True
			if m_redirect:
				self.actual_url = m_redirect.group(1)
				refresh = True
			
			if self.lastline != line:
				refresh = True
			self.lastline = line
			if refresh:
				refresh_download_state(self)
		fh.close()
		self.running = False
		self['status'] = S_ERR
		self['pid'] = None
		refresh_download_state(self)
		start_next_download(self)
	def stop(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], signal.SIGTERM)
				self['status'] = S_STOP
			except OSError as e:
				if e.errno != os.errno.ESRCH:
					raise e

class DataDownload(BaseDownload):
	Decoder = {
		'base64': base64.decodestring,
		'url': urllib.unquote,
	}
	def __init__(self, url, params={}):
		super(DataDownload, self).__init__(url, params)
		self.init()
	def get_url(self):
		return None
	def start(self):
		if self.completed or self.original_url is None:
			return False
		t1 = threading.Thread(target=self.worker)
		t1.daemon = True
		t1.start()
	def worker(self):
		self['status'] = S_INIT
		self.running = True
		try:
			encoding = 'url'
			try:
				m = re.match('^data:(?:([^,]*),)?(.*)', self.original_url)
				meta, data = m.groups()
				if meta is None: meta = ''
			except ValueError:
				raise Exception(_("Can not parse URL."))
			# Free memory:
			self.original_url = None
			for m in meta.split(';'):
				if m.startswith('charset='):
					self.charset = m[8:]
				elif re.match('.*/', m):
					self.mime_remote = m
				elif m in ['base64']:
					encoding = m
			
			directory = self.params['--directory-prefix']
			basename = 'data-'
			num = next_file_number(glob.escape(os.path.join(directory, basename)), '.*')
			ext = guess_extension(self.mime_remote or MIME_DEFAULT) or '.dat'
			filename = '%s%d%s' % (basename, num, ext)
			self.outfile = os.path.join(directory, filename)
			
			try:
				decoder = self.Decoder[encoding]
			except KeyError:
				raise Exception(_("Unknown encoding: %s" % (encoding)))
			try:
				fh = open(self.outfile, 'w')
				self['status'] = S_DL
				fh.write(decoder(data))
				self.size = fh.tell()
				fh.close()
				self.percent = 100
			except IOError as e:
				raise Exception(e)
			
			self.running = False
			self.mark_completed()
		except Exception as e:
			self['status'] = S_ERR
			self.running = False
			refresh_download_state(self)
			display_error(e)
	def stop(self):
		return False

def column_width_change(col, pspec):
	sid = col.get_data('signal-notify::width')
	w = col.get_property(pspec.name)
	col.set_data('reported-width', w)
	if not scroller.get_data('initial-column-resize'):
		if all(map(lambda col: col.get_data('reported-width'), main_list.get_columns())):
			scroller.set_data('initial-column-resize', True)
			for col in main_list.get_columns():
				col.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
				col.set_fixed_width(col.get_data('reported-width'))
			resize_column0()
			win_main.connect('configure-event', win_main_configure)
	if win_main.get_data('resized'):
		win_main.remove_data('resized')
		resize_column0()

def resize_column0():
	cols = main_list.get_columns()
	if all(map(lambda col: col.get_data('reported-width'), cols)):
		total = scroller.get_allocation().width
		midwidth = 0
		for col in cols[1:-1]:
			midwidth += col.get_data('reported-width')
		treeview_column_set_width(cols[0], total - midwidth - 24)

def treeview_column_set_width(col, width):
	col.set_data('column-width', width)
	if col.get_sizing() == gtk.TREE_VIEW_COLUMN_FIXED:
		col.set_fixed_width(width)
	else:
		col.set_min_width(width)
		col.set_max_width(width)
		glib.idle_add(lambda: (col.set_min_width(-1), col.set_max_width(-1)), priority=glib.PRIORITY_DEFAULT_IDLE)

def win_main_configure(win, evt):
	if win_main.get_data('saved-width') != evt.width or win_main.get_data('saved-height') != evt.height:
		win_main.set_data('resized', True)
		win_main.set_data('saved-width', evt.width)
		win_main.set_data('saved-height', evt.height)
		# Trigger column-width change:
		col0 = main_list.get_columns()[0]
		w = col0.get_data('column-width')
		treeview_column_set_width(col0, w+1)

def lock_row_refresh(doLock):
	main_list.set_data('refresh-lock', doLock)
	row = main_list.get_data('editing-row')
	if doLock:
		if row[COL_DLOBJ].running:
			QUESTIONMARKS = '???'
			row[COL_PRCSTR] = QUESTIONMARKS
			row[COL_SPEED_STR] = QUESTIONMARKS
			row[COL_STATUS_ICON] = StatusIcon[S_GUILOCK]
			row[COL_STATUS] = _(Status[S_GUILOCK])
			row[COL_ETA_STR] = QUESTIONMARKS
	else:
		refresh_download_state(row[COL_DLOBJ])

def treeview_column0_editing(cellrenderer, editable, rownum):
	row = DownLoadList[DownLoadList.get_iter_from_string(rownum)]
	main_list.set_data('editing-row', row)
	dl = row[COL_DLOBJ]
	if isinstance(dl, BaseDownload):
		if not os.path.exists(dl.outfile):
			row[COL_NAMEEDITABLE] = False
			return
	lock_row_refresh(True)

def treeview_column0_edited(cellrenderer, itpathstr, newtext):
	row = main_list.get_data('editing-row')
	dl = row[COL_DLOBJ]
	if isinstance(dl, Folder):
		dl.rename(newtext)
	elif isinstance(dl, BaseDownload):
		if dl.outfile:
			newpath = os.path.join(os.path.dirname(dl.outfile), newtext)
			if rename_downloaded_file(dl, newpath):
				dl.manually_renamed = True
				if os.path.isabs(newtext):
					dl.params['rename_to'] = newpath
				else:
					dl.params['rename_to'] = relative_path(newpath, dl.params['--directory-prefix'])
	lock_row_refresh(False)

def treeview_column0_edit_canceled(cellrenderer):
	lock_row_refresh(False)

def win_main_show():
	# Manage GUI
	
	# Load cached downloads from object dumps
	import_downloads()
	
	# Add signals for each column
	for col in main_list.get_columns():
		sid = col.connect('notify::width', column_width_change)
		col.set_data('signal-notify::width', sid)
	
	# Start background thread
	continous_refresh_thread = threading.Thread(target=continous_refresh, args=(60,))
	continous_refresh_thread.daemon = True
	continous_refresh_thread.start()
	
	# Parse CLI args
	main_parse_cli(sys.argv)

def main_parse_cli(argv, append_url = False, cwd = None):
	cliURLs = []
	cliOpts = []
	idx = 1
	while idx < len(argv):
		arg = argv[idx]
		if arg.startswith('-'):
			m = re.search('([^=]+)=(.*)', arg)
			if m:
				key, val = m.group(1), m.group(2)
			else:
				key = arg
				val = None
				if key.startswith('--no-'):
					key = '--' + key[5:]
					val = False
				elif key not in ParameterlessOptions and idx+1 < len(argv):
					argnext = argv[idx+1]
					if not argnext.startswith('-'):
						val = argnext
						idx += 1
			cliOpts.append((key, val))
		else:
			cliURLs.append(arg)
		idx += 1
	
	# Sort --rename-to behind of --output-document to take precedence over it.
	idx = 0
	while idx < len(cliOpts):
		if cliOpts[idx][0] == '--rename-to':
			if any(x[0] != '--rename-to' for x in cliOpts[idx:]):
				cliOpts = cliOpts[:idx] + cliOpts[idx+1:] + cliOpts[idx:idx+1]
				idx -= 1
		idx += 1
	
	# Setup New Download panel with URL(s) and options given in CLI.
	subsequent = win_newdl.props.visible
	if not subsequent:
		reset_parameters()
	params = {}
	for optnam, optval in cliOpts:
		if ShortLongOptions.has_key(optnam):
			optnam = ShortLongOptions[optnam]
			
		if optnam == '--cwd-prefix':
			optval = cwd or os.getcwd()
		elif optnam == '--output-document':
			if optval.find(os.path.sep) > -1:
				if any(x[0] == '--directory-prefix' for x in cliOpts):
					stderr(_("Path is given by `--output-document´ but `--directory-prefix´ is also given.")+'\n')
					stderr(_("Using basename of `--output-document´.")+'\n')
				else:
					cliOpts.append(('--directory-prefix', os.path.dirname(optval)))
				optval = os.path.basename(optval)
				stderr(_("Consider gwget option `--rename-to´ instead of `--output-document´ next time.")+'\n')
		if GWgetOptionsParam.has_key(optnam):
			optnam = GWgetOptionsParam[optnam]
		
		for prmdisp in ParamDispatchers.values():
			# Refresh New Download panel's widgets.
			prmdisp.cond_update_params_dict(params, optnam, optval, force = not subsequent)
	
	if params.has_key('--directory-prefix'):
		prepend_uniq(LastFolders, params['--directory-prefix'])
	
	if cliURLs:
		old_urls = p1t1.get_text()
		new_urls = '\n'.join(cliURLs) + '\n'
		if subsequent and append_url:
			new_urls = old_urls + ('' if len(old_urls)==0 or old_urls[-1] == '\n' else '\n') + new_urls
		p1t1.set_text(new_urls)
	
	if cliOpts or cliURLs:
		show_win_newdl()

def act_quit():
	if any(dl.running for it, dl in iter_downloadtree(BaseDownload)) and not question(_("Running downloads will continue in the background.\nQuit anyway?"), yes=gtk.STOCK_QUIT, default=gtk.RESPONSE_NO):
		return True
	export_downloads()
	gtk.main_quit()
	return False


def find_parent_iter_by_pathid(pathid):
	if pathid is None or len(pathid) == 1: return None
	def each(model, path, it, result):
		if result[0] is not None: return
		if model[it][COL_DLOBJ].pathid == ppathid: result[0] = it
	ppathid = pathid[:-1]
	result = [None]
	DownLoadList.foreach(each, result)
	return result[0]

def import_downloads():
	# TODO keep order
	items = []
	for f in os.listdir(CacheFolder):
		if re.match('^gwget-\d+\.obj$', f):
			f = os.path.join(CacheFolder, f)
			fh = open(f, 'r')
			try:
				obj = pickle.load(fh)
			except EOFError:
				stderr((_("Can not load object: %s") % (f,))+'\n')
			fh.close()
			obj.resurgo()
			items.append(obj)
	while True:
		n_items = len(items)
		for obj in items:
			parent = find_parent_iter_by_pathid(obj.pathid)
			if parent is not None or len(obj.pathid) < 2:
				DownLoadList_append_new({COL_DLOBJ: obj}, parent=parent)
				del items[items.index(obj)]
		if len(items) == n_items:
			for obj in items:
				DownLoadList_append_new({COL_DLOBJ: obj})
			break
	def expander(model, path, it):
		if hasattr(model[it][COL_DLOBJ], 'expanded') and bool(model[it][COL_DLOBJ].expanded):
			main_list.expand_row(path, open_all=False)
	DownLoadList.foreach(expander)
	refresh_download_state_all()

def export_downloads():
	def each(model, path, it):
		dl = model[it][COL_DLOBJ]
		dl.expanded = main_list.row_expanded(path)
		dl.pathid = path
		dl.morior()
		fh = open(dl.get_dumpfile(), 'w')
		pickle.dump(dl, fh)
		fh.close()
	DownLoadList.foreach(each)

class iter_downloadtree(object):
	def __init__(self, onlyclass=None):
		self.model = DownLoadList
		self.next_iter = self.model.get_iter_first()
		self.onlyclass = onlyclass
	def __iter__(self):
		return self
	def next(self):
		while True:
			self.cur_iter = self.next_iter
			if self.cur_iter is None:
				raise StopIteration
			if self.model.iter_has_child(self.cur_iter):
				# Jump to children.
				self.next_iter = self.model.iter_children(self.cur_iter)
			else:
				# Next sibling.
				self.next_iter = self.model.iter_next(self.cur_iter)
				if self.next_iter is None:
					# Continue on uncle.
					par = self.model.iter_parent(self.cur_iter)
					if par is not None:
						self.next_iter = self.model.iter_next(par)
			dlobj = self.model[self.cur_iter][COL_DLOBJ]
			if self.onlyclass is None or isinstance(dlobj, self.onlyclass):
				return (self.cur_iter, dlobj)
				break
	def __del__(self):
		pass

def called_by_self():
	# Prevent Deadlock
	stack = traceback.extract_stack()
	selfname = stack[-2][2]
	return any(c[2] == selfname for c in stack[:-2])

def refresh_download_state_all():
	return refresh_download_state(None)

def refresh_download_state(dlobj):
	if called_by_self():
		return
	if threading.currentThread().name != 'MainThread':
		gtk.threads_enter()
	doAll = dlobj is None
	for it, dl in iter_downloadtree(BaseTreeItem):
		row = DownLoadList[it]
		if doAll or dlobj == dl:
			if not(main_list.get_data('refresh-lock') and main_list.get_data('editing-row').path == DownLoadList[it].path):
				if isinstance(dl, BaseDownload):
					if dl.outfile is None:
						row[COL_NAME] = os.path.basename(re.sub('/+$', '', urlparse.urlparse(dl.get_url() or 'data').path))
					else:
						row[COL_NAME] = os.path.basename(dl.outfile)
						if os.path.exists(dl.outfile):
							row[COL_NAMEEDITABLE] = True
					
					mime = dl.mime_local
					if not mime:
						if dl.completed:
							dl.set_mime_local()
							mime = dl.mime_local
						if not dl.completed or mime is None:
							mime = dl.mime_remote
					icon = gio.content_type_get_icon(mime or MIME_DEFAULT)
					theme = gtk.icon_theme_get_default()
					info = theme.choose_icon(icon.get_names(), gtk.ICON_SIZE_MENU, 0)
					if info is not None:
						row[COL_FILE_ICON] = None
						row[COL_PXB] = info.load_icon()
					else:
						row[COL_PXB] = None
						row[COL_FILE_ICON] = gtk.STOCK_FILE
				
				if isinstance(dl, Folder):
					# TODO sum children
					pass
				else:
					if dl.percent >= 0:
						row[COL_PULSE] = -1
						row[COL_PERCENT] = dl.percent
						row[COL_PRCSTR] = str(dl.percent) + '%'
					else:
						row[COL_PERCENT] = 0
						if dl.running and not dl.completed:
							if row[COL_PULSE] < 0:
								row[COL_PULSE] = 0
							try: row[COL_PULSE] += 1
							except TypeError: row[COL_PULSE] = 1
						else:
							if dl.completed:
								row[COL_PERCENT] = 100
								row[COL_PULSE] = gobject.constants.G_MAXINT
							else:
								row[COL_PULSE] = 0
						row[COL_PRCSTR] = ''
					row[COL_STATUS_ICON] = StatusIcon[dl['status']]
					row[COL_STATUS] = _(Status[dl['status']])
					row[COL_MESSAGE] = '<tt>' + glib.markup_escape_text(dl.lastline) + '</tt>'
				
					row[COL_SPEED_BPS] = dl.speed
					row[COL_SPEED_STR] = dl.speed_str
					row[COL_ETA_SEC] = dl.eta
					row[COL_ETA_STR] = dl.eta_str
					row[COL_ADDED_TSTMP] = dl.added_ts
					row[COL_ADDED_DATE] = str_accurate_at_time(dl.added_ts)
			
			# If the current download is selected, then refresh toolbuttons sensitivity.
			if main_selection.iter_is_selected(it):
				on_selection_change(main_selection)
			if not doAll:
				break
	if threading.currentThread().name != 'MainThread':
		gtk.threads_leave()

def pulse_download(pid):
	for it, dl in iter_downloadtree(BaseDownload):
		try:
			if dl['pid'] == pid:
				DownLoadList[it][COL_PULSE] += 1
				break
		except KeyError:
			pass

def continous_refresh(wait):
	while True:
		refresh_download_state_all()
		time.sleep(wait)

def start_next_download(prev_dl):
	assert(prev_dl.get_url())
	this_host = urlparse.urlparse(prev_dl.get_url()).hostname
	start_dl = None
	for it, dl in sorted(iter_downloadtree(BaseDownload), key = lambda(it, dl): dl.added_ts):
		if not dl.get_url(): continue
		if dl.params['runnable'] and this_host == urlparse.urlparse(dl.get_url()).hostname:
			# this is a DL on the same host as the finished one was on
			if dl['status'] in [S_INIT, S_DL]:
				# if there is at least one DL initializing or downloading, then stop lookup
				start_dl = None
				break
			if start_dl is None and dl['status'] in [S_QUEUE]:
				# this is a queued DL, start it unless an other DL matched above
				start_dl = dl
	if start_dl is not None:
		start_dl.start()

def setxattributes(dl):
	attrs = {XATTR_URI: dl.original_url}
	if dl.mime_remote not in [None, MIME_DEFAULT]:
		attrs[XATTR_MIME] = dl.mime_remote
	if dl.params.has_key('--referer'):
		attrs[XATTR_REFERER] = dl.params['--referer']
	set_xattrs_file(dl.outfile, attrs)

def on_completed_download(dl):
	if os.path.exists(dl.outfile):
		setxattributes(dl)
		if not (hasattr(dl, 'manually_renamed') and dl.manually_renamed):
			rename_to_filepath = None
			warnfail = False
			if dl.params.has_key('rename_to'):
				# User requested renaming
				if os.path.isabs(dl.params['rename_to']):
					rename_to_filepath = dl.params['rename_to']
				else:
					rename_to_filepath = os.path.join(dl.params['--directory-prefix'], dl.params['rename_to'])
				mkdir(os.path.dirname(rename_to_filepath))
				warnfail = True
			elif isinstance(dl, DataDownload):
				# Data scheme, guess extension from content
				if dl.mime_local:
					path, extold = os.path.splitext(dl.outfile)
					extnew = guess_extension(dl.mime_local)
					if extnew and extnew != extold:
						rename_to_filepath = path + extnew
			elif re.match('.*\?[^?]+=', dl.outfile):
				# Otherwise strip URL query string from filename
				rename_to_filepath = re.sub('\?[^?]+=[^?]*', '', dl.outfile)
			if rename_to_filepath is not None:
				if rename_downloaded_file(dl, rename_to_filepath, warnfail=warnfail):
					setxattributes(dl)
				refresh_download_state(dl)
	if dl.params.has_key('on_complete'):
		s = dl.params['on_complete']
		SQ = '\''
		esc_filename = SQ + dl.outfile.replace(SQ, SQ+'\\'+SQ+SQ) + SQ
		shcmd = s.replace('{}', esc_filename)
		try:
			workdir = dl.params['--directory-prefix']
		except KeyError:
			workdir = None
		run_detached('sh', ['-c', shcmd], workdir)

def rename_downloaded_file(dl, newpath, warnfail=True):
	if dl.outfile == newpath:
		return None
	if os.path.exists(newpath):
		display_error(_("Target already exists, not renaming.\nFile: <tt>%s</tt>\nTarget: <tt>%s</tt>") % (glib.markup_escape_text(dl.outfile), glib.markup_escape_text(newpath)), isPango=True, gtkErrorLevel=gtk.MESSAGE_WARNING)
	else:
		try:
			try:
				os.rename(dl.outfile, newpath)
			except OSError as e:
				if e.errno == os.errno.EXDEV:
					if dl.completed:
						cmd = run_synchronous('mv', ['--no-clobber', dl.outfile, newpath])
						if cmd.exitcode != 0:
							e = ShellCommandException()
							e.message = re.sub('\n*$', '', cmd.stderr)
							e.errno = cmd.exitcode
							raise e
					else:
						if e.message: e.message += '\n'
						e.message += _("Refused moving an incompleted file across filesystems.")
						raise e
				else:
					raise e
		except (OSError, ShellCommandException) as e:
			e.filename = None
			e.filenames = [dl.outfile, newpath]
			display_error(e)
		else:
			dl.outfile = newpath
			return True
	return False

def DownLoadList_append_new(dldict, parent=None, after=None):
	return DownLoadList_add_new(dldict, parent=parent, after=after)

def DownLoadList_add_new(dldict, parent=None, after=None):
	# COL_DLOBJ, COL_NAME, COL_FILE_ICON, COL_PXB, COL_ADDED_TSTMP, COL_ADDED_DATE, 
	#   COL_PRCSTR, COL_PERCENT, COL_PULSE, COL_SPEED_BPS, COL_SPEED_STR, 
	#   COL_ETA_SEC, COL_ETA_STR, COL_STATUS_ICON, COL_STATUS, COL_MESSAGE, COL_NAMEEDITABLE
	# DownLoadList = gtk.ListStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, int, str, 
	#   str, float, int, float, str, 
	#   int, str, str, str, str, bool)
	# it = DownLoadList.append([dl, os.path.basename(url), gtk.STOCK_FILE, None, int(time.time()), str_accurate_at_time(time.time()), 
	#   '', 0, 0, -1, '', 
	#   -1, '', gtk.STOCK_MEDIA_STOP, _(Status[S_QUEUE]), '', False])
	row = [None, '', '', None, 0, '', '', 0, 0, -1, '', -1, '', '', '', '', False]
	for idx, val in dldict.iteritems():
		row[idx] = val
	newiter = DownLoadList.insert_after(parent, after, row)
	row[COL_DLOBJ].row = DownLoadList[newiter]
	row[COL_DLOBJ].materialized()
	return newiter

def DownLoadList_add_new_folder(parent=None, after=None):
	return DownLoadList_add_new(
		{COL_DLOBJ: Folder(_("Folder")), COL_FILE_ICON: gtk.STOCK_DIRECTORY, COL_NAMEEDITABLE: True,},
		parent = parent, after = after)

def start_new_download(url, params, start=True):
	urlparts = urlparse.urlparse(url)
	if urlparts.scheme == 'data':
		dl = DataDownload(url, params)
		start = True
	else:
		dl = Download(url, params)
	it = DownLoadList_append_new({COL_DLOBJ: dl})
	refresh_download_state(dl)
	if start:
		dl.start()
	return it

def reset_parameters(params={}):
	for opt, prmdisp in ParamDispatchers.iteritems():
		if params.has_key(opt):
			# Fill widgets with given wget parameters.
			prmdisp.set_value(params[opt], reset=True)
		else:
			# Reset widget to empty/default values.
			prmdisp.set_value(None, reset=True)

def show_win_newdl():
	win_newdl.show()
	for n in reversed(range(0, note.get_n_pages())):
		note.set_current_page(n)
	p1t1.grab_focus()
	p1c1.set_history(LastFolders)



### Interface procedures ###

def act_new():
	show_win_newdl()
	reset_parameters()

def act_new_folder():
	parent = None
	after = None
	itpaths = main_selection.get_selected_rows()[1]
	if len(itpaths) > 0:
		parent = DownLoadList.get_iter(itpaths[0])
		if not isinstance(DownLoadList[parent][COL_DLOBJ], Folder):
			after = parent
			parent = DownLoadList.iter_parent(parent)
	it = DownLoadList_add_new_folder(parent=parent, after=after)
	itpath = DownLoadList.get_path(it)
	main_list.expand_to_path(itpath)
	main_selection.unselect_all()
	main_selection.select_iter(it)
	main_list.set_cursor(itpath, focus_column=tvc0, start_editing=True)

def act_select_completed():
	main_selection.unselect_all()
	for it, dl in iter_downloadtree(BaseDownload):
		if dl.completed:
			main_selection.select_iter(it)

def act_resume_all():
	for it, dl in iter_downloadtree(BaseDownload):
		if not dl.running and not dl.completed:
			act_start(None, dl)

def act_pause_all():
	for it, dl in iter_downloadtree(BaseDownload):
		if dl.running:
			act_pause(None, dl)
		elif dl['status'] == S_QUEUE:
			dl.params['runnable'] = False

def act_expand_all():
	main_list.expand_all()

def act_collapse_all():
	main_list.collapse_all()

def act_options():
	win_opts = gtk.Window()
	win_opts.set_title(_("Options"))
	win_opts.set_icon_name('emblem-downloads')
	win_opts.connect('delete-event', lambda w,e: w.destroy())
	add_key_binding(win_opts, 'Escape', lambda a,b,c,d: win_opts.destroy() or True)
	win_opts.set_transient_for(win_main)
	win_opts.set_modal(True)
	vbox = gtk.VBox()
	win_opts.add(vbox)
	win_opts.show_all()


def shell_open(path):
	return run_detached('mimeopen-gui', [path])

def act_open_file(it, dl):
	if dl.outfile is not None:
		shell_open(dl.outfile)

def act_open_folder(it, dl):
	shell_open(os.path.dirname(dl.outfile))

def act_open_referer(it, dl):
	shell_open(dl.params['--referer'])

def act_open_clipboard(it, dl):
	Clipboard.set_text(dl.outfile)

def act_start(it, dl):
	dl.start()

def act_resume(it, dl):
	if not dl.running and not dl.completed:
		dl.start()

def act_refetch(it, dl):
	if dl.outfile is not None:
		delete(dl.outfile)
	dl.start()

def act_pause(it, dl):
	dl.stop()

def act_remove_download(it, dl, force=False):
	if not dl.running and dl.outfile is not None:
		if not dl.completed or force or question(_("Do you want to <b>delete completed</b> file?\nURL: <tt>%s</tt>\nFile: <tt>%s</tt>") % (glib.markup_escape_text(dl.original_url or '') or MDASH_UTF8, glib.markup_escape_text(dl.outfile or '') or MDASH_UTF8), yes=gtk.STOCK_DELETE, default=gtk.RESPONSE_NO):
			delete(dl.outfile)

def TreeModel_iter_prev(model, it):
	itpath = model.get_string_from_iter(it).split(':')
	if itpath[-1] == '0':
		return None
	else:
		itpath[-1] = str(int(itpath[-1]) - 1)
	return model.get_iter_from_string(':'.join(itpath))

def DownLoadList_move(iterator, parent=None, sibling=None):
	d = dict(zip(range(len(DownLoadList[iterator])), DownLoadList[iterator]))
	moved_it = DownLoadList_append_new(d, parent=parent, after=sibling)
	child_moved_it = None
	while DownLoadList.iter_has_child(iterator):
		child_moved_it = DownLoadList_move(DownLoadList.iter_children(iterator), moved_it, child_moved_it)
	del DownLoadList[iterator]
	return moved_it

def act_clear_download(it, dl):
	if isinstance(dl, Folder):
		main_selection.unselect_all()
		# Move all children to one level up.
		parent = DownLoadList.iter_parent(it)
		sibling = it
		while DownLoadList.iter_has_child(it):
			moved_it = DownLoadList_move(DownLoadList.iter_children(it), parent, sibling)
			main_selection.select_iter(moved_it)
			sibling = moved_it
		del DownLoadList[it]
		delete(dl.get_dumpfile())
	else:
		if not dl.running:
			if not dl.completed and dl.outfile is not None and os.path.exists(dl.outfile):
				try:
					if question(_("This download is not completed.\nDo you want to <b>delete partial</b> file?\nURL: <tt>%s</tt>\nFile: <tt>%s</tt>") % (glib.markup_escape_text(dl.original_url or '') or MDASH_UTF8, glib.markup_escape_text(dl.outfile or '') or MDASH_UTF8), yes=gtk.STOCK_DELETE, no=(_("Clear"), gtk.STOCK_CLEAR), cancelable=True, default=gtk.RESPONSE_CANCEL):
						act_remove_download(it, dl, force=True)
				except DialogCancel:
					return
			if dl.logfile is not None:
				untrack_download_file(dl)
			del DownLoadList[it]

def untrack_download_file(dl):
	delete(dl.get_dumpfile())
	delete(dl.logfile)

def act_show_log(it, dl):
	def add_context_menuitems(txv, menu, scrtxv):
		menu.prepend(gtk.SeparatorMenuItem())
		mi = StockMenuItem(None, gtk.STOCK_REFRESH)
		mi.connect('activate', lambda mi, *userparams: simple_load_file_into_scrolledtextview(*userparams), dl.logfile, scrtxv)
		menu.prepend(mi)
		menu.show_all()
	
	win_log = gtk.Window()
	scrtxv = ScrolledTextView()
	win_log.set_default_size(675, 345)
	win_log.set_title(_("Log - %s") % (os.path.basename(dl.logfile)))
	win_log.set_icon_name('emblem-downloads')
	win_log.connect('delete-event', lambda w,e: w.destroy())
	add_key_binding(win_log, 'Escape', lambda a,b,c,d: win_log.destroy() or True)
	win_log.set_transient_for(win_main)
	win_log.set_modal(True)
	win_log.add(scrtxv)
	scrtxv.set_editable(False)
	scrtxv.get_textview().connect('populate-popup', add_context_menuitems, scrtxv)
	win_log.show_all()
	simple_load_file_into_scrolledtextview(dl.logfile, scrtxv)

def simple_load_file_into_scrolledtextview(filepath, textview):
	try:
		fh = open(filepath, 'r')
		textview.set_text(''.join(fh.readlines()))
		fh.close()
	except IOError as e:
		display_error(e)

def act_props(it, dl):
	#stderr(str(dl.__dict__)+'\n')
	show_win_newdl()
	reset_parameters(dl.params)
	p1t1.set_text(dl.original_url or '')

def act_select(it, dl):
	main_selection.select_iter(it)

def act_on_selection(func, maxi=None):
	iters = []
	for itpath in sorted(main_selection.get_selected_rows()[1], key=len, reverse=True):
		iters.append(DownLoadList.get_iter(itpath))
	if maxi is None or len(iters) <= maxi:
		for it in iters:
			func(it, DownLoadList[it][COL_DLOBJ])

def on_selection_change(selection):
	# TODO Folders
	iters = map(lambda p: DownLoadList.get_iter(p), selection.get_selected_rows()[1])
	dls = map(lambda it: DownLoadList[it][COL_DLOBJ], iters)
	num = len(iters)
	btn_resume.set_sensitive(num>0 and all(not dl.running and not(dl.completed and os.path.exists(dl.outfile)) for dl in dls))
	btn_pause.set_sensitive(num>0 and all(dl.running for dl in dls))
	btn_clear.set_sensitive(num>0 and all(not dl.running for dl in dls))
	btn_props.set_sensitive(num == 1)

def on_context_menu(menuitem, function):
	it = ContextMenu.get_data('iterator')
	dl = DownLoadList[it][COL_DLOBJ]
	function(it, dl)
	return True

def on_level_context_menu(menuitem, function):
	rows = []
	folder_it = FolderContextMenu.get_data('iterator')
	child_it = DownLoadList.iter_children(folder_it)
	while child_it is not None:
		rows.append(DownLoadList[child_it])
		child_it = DownLoadList.iter_next(child_it)
	for row in rows:
		child_it = row.iter
		dl = row[COL_DLOBJ]
		if not isinstance(dl, Folder):
			function(child_it, dl)
	return True

def event_masked(event):
	return any(event.state & getattr(gtk.gdk, mask+'_MASK') for mask in ['CONTROL','SHIFT','MOD4','MOD5','META'])

def popup_context_menu(it, event, button=None, placement_func=None):
	dl = DownLoadList[it][COL_DLOBJ]
	if isinstance(dl, BaseDownload):
		ctx_menu = ContextMenu
		cmi_open_file.set_sensitive(dl.outfile is not None)
		cmi_open_referer.set_sensitive(dl.params.has_key('--referer'))
		cmi_remove.set_sensitive(dl.outfile is not None and not dl.running and os.path.exists(dl.outfile))
		cmi_refetch.set_sensitive(not dl.running)
		cmi_resume.set_sensitive(not dl.running and not(dl.completed and os.path.exists(dl.outfile)))
		cmi_pause.set_sensitive(dl.running)
		cmi_clear.set_sensitive(not dl.running)
	else:
		ctx_menu = FolderContextMenu
	ctx_menu.set_data('iterator', it)
	if button is None: button = event.button
	ctx_menu.popup(None, None, placement_func, button, event.time)

def on_urls_edited(buf):
	if len(p1t1.get_text().split()) > 1:
		p1e1.hide()
	else:
		p1e1.show()

def on_treeview_click(tree, event):
	if event_masked(event):
		return False
	itpathinfo = main_list.get_path_at_pos(int(event.x), int(event.y))
	if itpathinfo is not None:
		itpath, col, cellx, celly = itpathinfo
		it = DownLoadList.get_iter(itpath)
		dl = DownLoadList[it][COL_DLOBJ]
		if event.type == gtk.gdk.BUTTON_PRESS and event.button == 3:
			# Right click
			main_selection.unselect_all()
			main_selection.select_iter(it)
			popup_context_menu(it, event)
			return True
		elif event.type == gtk.gdk._2BUTTON_PRESS and event.button == 1:
			# Left double click
			act_open_file(it, dl)
			return True
	return False

def on_treeview_key(tree, event):
	if event_masked(event):
		return False
	if event.keyval == gtk.gdk.keyval_from_name('Delete'):
		act_on_selection(act_clear_download)
		return True
	rows = main_selection.get_selected_rows()[1]
	if len(rows) == 1:
		it = DownLoadList.get_iter(rows[0])
	if event.keyval == gtk.gdk.keyval_from_name('Menu'):
		if len(rows) == 1:
			x, y = tree.window.get_origin()
			popup_context_menu(it, event, 3, placement_func = lambda d: (x, y, True))
			return True
	if event.keyval in map(gtk.gdk.keyval_from_name, ['Return', 'KP_Enter']):
		if len(rows) == 1:
			dl = DownLoadList[it][COL_DLOBJ]
			if isinstance(dl, BaseDownload):
				act_open_file(it, dl)
		return True
	return False


## New Download window

# Start new download(s)
def new_download(start=True, doOpen=False):
	selected_folder = ParamDispatchers['--directory-prefix'].get_value()
	prepend_uniq(LastFolders, selected_folder)
	
	# Read widgets and build up wget parameters.
	params = {}
	for prmdisp in ParamDispatchers.values():
		prmdisp.update_params_dict(params)
	if doOpen:
		params['on_complete'] = 'mimeopen-gui {}'
	params['runnable'] = bool(start)
	
	main_selection.unselect_all()
	uniq_url = {}
	uniq_host = {}
	# TODO if multiple url then create new folder for them and expand the folder
	for url in p1t1.get_text().split():
		if not uniq_url.has_key(url):
			this_hostname = urlparse.urlparse(url).hostname
			if start:
				start_this = all(this_hostname != host for host in uniq_host.iterkeys())
			else:
				start_this = False
			it = start_new_download(url, params, start=start_this)
			main_selection.select_iter(it)
			uniq_url[url] = 1
			uniq_host[this_hostname] = 1
	win_newdl.hide()

def DnD_motion(wdg, context, x, y, time):
	action = None
	for act in gtk.gdk.ACTION_COPY, gtk.gdk.ACTION_MOVE:
		if context.suggested_action & act:
			action = act
			break
	if action is not None:
		if 'text/plain' in context.targets:
			wdg.drag_highlight()
			context.drag_status(action, time)
			return True
		if 'GTK_TREE_MODEL_ROW' in context.targets:
			drop_dest = main_list.get_dest_row_at_pos(x, y)
			if drop_dest is not None:
				itpath, droppos = drop_dest[:]
				main_list.set_drag_dest_row(itpath, droppos)
				context.drag_status(action, time)
				return True
	return False

def DnD_accept(wdg, context, x, y, time):
	accepted = False
	for typ in 'text/plain', 'GTK_TREE_MODEL_ROW':
		if typ in context.targets:
			if typ == 'GTK_TREE_MODEL_ROW':
				context.set_data('drop-dest', main_list.get_dest_row_at_pos(x, y))
			wdg.drag_get_data(context, typ, time)
			accepted = True
			break
	context.drop_reply(accepted, time)
	wdg.drag_unhighlight()
	return True

def DnD_receive(wdg, context, x, y, selectiondata, info, time):
	success = False
	if selectiondata.get_length() > -1:
		typ = selectiondata.get_data_type()
		if typ == 'text/plain':
			urls = '\n'.join(selectiondata.get_text().split())+'\n'
			act_new()
			p1t1.set_text(urls)
			if context.action == gtk.gdk.ACTION_MOVE:
				new_download()
			success = True
		elif typ == 'GTK_TREE_MODEL_ROW':
			model, subject = selectiondata.tree_get_row_drag_data()
			itpath, droppos = context.get_data('drop-dest')
			relative = DownLoadList.get_iter(itpath)
			if droppos in [gtk.TREE_VIEW_DROP_BEFORE, gtk.TREE_VIEW_DROP_AFTER] or not isinstance(DownLoadList[relative][COL_DLOBJ], Folder):
				parent = DownLoadList.iter_parent(relative)
				sibling = relative
				if droppos == gtk.TREE_VIEW_DROP_BEFORE:
					sibling = TreeModel_iter_prev(DownLoadList, sibling)
			else:
				parent = relative
				sibling = None
			# TODO make disorder
			DownLoadList_move(DownLoadList.get_iter(subject), parent, sibling)
			success = True
	context.finish(success, False, time)
	return True

class GwgetService(dbus.service.Object):
	def __init__(self, win_main):
		self.win = win_main
		bus_name = dbus.service.BusName(APPNAME, bus = dbus.SessionBus())
		dbus.service.Object.__init__(self, bus_name, '/'+APPNAME.replace('.', '/'))
	@dbus.service.method(dbus_interface = APPNAME)
	def new_download(self, args, cwd):
		gtk.threads_enter()
		if len(args) < 2:
			self.win.present()
		main_parse_cli(args, append_url=True, cwd=cwd)
		gtk.threads_leave()

class ParamDispatcher(object):
	def __init__(self, widget, optname):
		self.widget = widget
		self.optname = optname
		self.negative_optname = self.negate_optname(optname)
		self.ext_getter = None
		self.ext_setter = None
	@staticmethod
	def negate_optname(optname):
		if optname.startswith('--'):
			if optname.startswith('--no-'):
				return '--' + optname[5:]
			else:
				return '--no-' + optname[2:]
		else:
			return None
	@staticmethod
	def convert_to_wget_args(params):
		wget_args_all = []
		for k, v in params.iteritems():
			if k.startswith('-'):
				if type(v) == list:
					for v1 in v:
						wget_args_all.append(k)
						wget_args_all.append(v1)
				elif v != '':
					if k.startswith('--') and v is False:
						k = '--no-' + k[2:]
					wget_args_all.append(k)
					if v not in [True, False, None]:
						wget_args_all.append(v)
			elif k == '':
				# append custom options
				for v1 in v:
					wget_args_all.append(v1)
			# TODO iterate through not on params but on ParamDispatchers
			elif k == 'header_cookies':
				wget_args_all.append('--header')
				wget_args_all.append('Cookie: ' + v)
		return wget_args_all
	@staticmethod
	def update_unknown_param(params, option, optval=None):
		if not params.has_key(''):
			params[''] = []
		if optval is False:
			appendix = ['--no-' + option[2:]]
		else:
			appendix = [option]
			if optval not in [None, True]:
				appendix += [optval]
		params[''] += appendix
		return appendix
	def cond_update_params_dict(self, params, optnam, optval, force=False):
		if self.optname == '' and not ParamDispatchers.has_key(optnam) and not ParamDispatchers.has_key(self.negate_optname(optnam)):
			new_args = self.update_unknown_param(params, optnam, optval)
			# Append to other wget options field.
			self.set_value(self.get_value() + new_args)
			return
		if optnam not in [self.optname, self.negative_optname]:
			return False
		
		if not force:
			first_set_value = self.widget.get_data('initial')
			if first_set_value:
				# Do not overwrite if has been set.
				return
			else:
				current_raw_val = self.get_raw_value()
				if first_set_value is None:
					default_val = self.widget.get_data('default-value')
					if default_val is not None and current_raw_val != default_val:
						# Do not overwrite if edited by user.
						return
				elif first_set_value == '':
					# Do not overwrite if edited by user.
					if current_raw_val != '':
						return
		
		if self.optname in ParameterlessOptions and optval is None:
			optval = (optnam == self.optname)
		self.set_value(optval)
		self.update_params_dict(params)
	def update_params_dict(self, params):
		val = self.get_value()
		if val is None:
			if params.has_key(self.optname):
				del params[self.optname]
		else:
			typ = type(val)
			if typ == bool:
				if val and params.has_key(self.negative_optname):
					del params[self.negative_optname]
				elif not val and params.has_key(self.optname):
					del params[self.optname]
			if typ in [float, int]:
				params[self.optname] = str(int(val))
			elif typ == list:
				# Returning type is list, append to the list of values.
				if not params.has_key(self.optname):
					params[self.optname] = []
				if type(params[self.optname]) != list:
					params[self.optname] = [params[self.optname]]
				params[self.optname] += val
			# Disallow empty option parameters.
			elif val != '':
				params[self.optname] = val
	def get_raw_value(self):
		if isinstance(self.widget, gtk.CheckButton):
			val = self.widget.get_active()
		elif isinstance(self.widget, gtk.SpinButton):
			val = self.widget.get_value()
		else:
			val = self.widget.get_text()
		return val
	def get_value(self):
		# Get value by method proper to widget type
		val = self.get_raw_value()
		if self.ext_getter is False:
			val = None
		elif self.ext_getter is not None:
			# Filter value by extender function
			sgn = inspect.getargspec(self.ext_getter)
			if len(sgn.args) < 2 and sgn.varargs is None:
				val = self.ext_getter(val)
			else:
				val = self.ext_getter(val, self.widget)
		return val
	def set_getter(self, fnc):
		self.ext_getter = fnc
	def set_value(self, val, reset=False):
		self.widget.set_data('initial', val)
		if val is None:
			val = self.widget.get_data('default-value')
		else:
			if self.ext_setter:
				sgn = inspect.getargspec(self.ext_setter)
				if len(sgn.args) < 2 and sgn.varargs is None:
					val = self.ext_setter(val)
				else:
					val = self.ext_setter(val, self.widget)
		
		if isinstance(self.widget, gtk.CheckButton):
			self.widget.set_active(bool(val))
		elif isinstance(self.widget, gtk.SpinButton):
			if val is None: val = 0
			self.widget.set_value(int(val))
		else:
			if isinstance(self.widget, ScrolledTextView):
				# Append option value to TextView text.
				if val is not None:
					cur = self.widget.get_text()
					val = cur + ('' if cur=='' or cur[-1] == '\n' else '\n') + val
			if val is None: val = ''
			self.widget.set_text(str(val))
	def set_putter(self, fnc):
		self.ext_setter = fnc
	def __repr__(self):
		return '<ParamDispatcher %s=%s>' % (self.optname, repr(self.get_value()),)



### Main ###

setproctitle.setproctitle(PROGNAME)
gettext.textdomain(PROGNAME)
_ = gettext.gettext
LastFolder = os.getcwd()
LastFolders = [LastFolder]
XATTR_URI = 'user.xdg.origin.url'
XATTR_REFERER = 'user.xdg.referrer.url'
XATTR_MIME = 'user.mime_type'
XATTR_CHARSET = 'user.charset'
MDASH_UTF8 = '—'
MIME_DEFAULT = 'application/octet-stream'
CacheFolder = os.path.join(os.environ['HOME'], '.cache', 'gwget')
COL_DLOBJ, COL_NAME, COL_FILE_ICON, COL_PXB, COL_ADDED_TSTMP, COL_ADDED_DATE, COL_PRCSTR, COL_PERCENT, COL_PULSE, COL_SPEED_BPS, COL_SPEED_STR, COL_ETA_SEC, COL_ETA_STR, COL_STATUS_ICON, COL_STATUS, COL_MESSAGE, COL_NAMEEDITABLE = range(17)
DownLoadList = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, float, str, str, float, int, float, str, int, str, str, str, str, bool)
S_QUEUE, S_INIT, S_DL, S_SAVED, S_ERR, S_STOP, S_GUILOCK = range(7)
Status = {
	S_QUEUE: "Queued",
	S_INIT: "Init",
	S_DL: "Download",
	S_SAVED: "Saved",
	S_ERR: "Failed",
	S_STOP: "Paused",
	S_GUILOCK: "Editing",
}
StatusIcon = {
	S_QUEUE: gtk.STOCK_MEDIA_STOP,
	S_INIT: 'media-seek-forward',
	S_DL: 'media-playback-start',
	S_SAVED: gtk.STOCK_APPLY,
	S_ERR: gtk.STOCK_NO,
	S_STOP: gtk.STOCK_MEDIA_PAUSE,
	S_GUILOCK: gtk.STOCK_EDIT,
}
# gwget cli options not requiring parameter
ParameterlessOptions = ['--cwd-prefix', '--content-disposition']
OSMaxFiles = resource.getrlimit(resource.RLIMIT_NOFILE)[0]


# Check if application is already running
if dbus.SessionBus().request_name(APPNAME) != dbus.bus.REQUEST_NAME_REPLY_PRIMARY_OWNER:
	stderr(PROGNAME+': '+_("Already running.")+'\n')
	method = dbus.SessionBus().get_object(APPNAME, '/'+APPNAME.replace('.', '/')).get_dbus_method('new_download')
	method(sys.argv, os.getcwd())
	raise SystemExit(0)


gtk.gdk.threads_init()
mkdir(CacheFolder)
Clipboard = gtk.Clipboard(selection='CLIPBOARD')


### Build GUI ###

## Main window

# Declare main window's widgets
win_main = gtk.Window()
box_main = gtk.VBox()
main_toolbar = gtk.Toolbar()
scroller = gtk.ScrolledWindow()
main_list = gtk.TreeView(DownLoadList)
main_selection = main_list.get_selection()
ContextMenu = gtk.Menu()
ContextMenuOpen = gtk.Menu()
cmi_open = StockMenuItem(None, gtk.STOCK_OPEN)
cmi_open_file = StockMenuItem(None, gtk.STOCK_OPEN)
cmi_open_folder = StockMenuItem(_("Open Folder"), gtk.STOCK_DIRECTORY)
cmi_open_referer = StockMenuItem(_("Open Website"), 'applications-internet')
cmi_open_clipboard = StockMenuItem(_("Copy path"), gtk.STOCK_COPY)
cmi_remove = StockMenuItem(_("Delete File"), gtk.STOCK_DELETE)
cmi_refetch = StockMenuItem(_("Re-download"), gtk.STOCK_REFRESH)
cmi_resume = StockMenuItem(_("Resume"), gtk.STOCK_MEDIA_PLAY)
cmi_pause = StockMenuItem(_("Pause"), gtk.STOCK_MEDIA_PAUSE)
cmi_clear = StockMenuItem(_("Clear"), gtk.STOCK_CLEAR)
cmi_log = StockMenuItem(_("Show Log"), gtk.STOCK_INFO)
cmi_props = StockMenuItem(None, gtk.STOCK_PROPERTIES)
FolderContextMenu = gtk.Menu()
fcmi_select = StockMenuItem(_("Select Level"), gtk.STOCK_INDENT)
fcmi_remove = StockMenuItem(_("Delete Files"), gtk.STOCK_DELETE)
fcmi_refetch = StockMenuItem(_("Re-download All"), gtk.STOCK_REFRESH)
fcmi_resume = StockMenuItem(_("Resume All"), gtk.STOCK_MEDIA_PLAY)
fcmi_pause = StockMenuItem(_("Pause All"), gtk.STOCK_MEDIA_PAUSE)
fcmi_clear = StockMenuItem(_("Clear All"), gtk.STOCK_CLEAR)


# Configure main window's widgets
win_main.set_default_size(950, 450)
win_main.set_title(_("Downloads"))
win_main.set_icon_name('emblem-downloads')
start_evt = win_main.connect('map-event', lambda w,e: (win_main.disconnect(start_evt), win_main_show()))
win_main.connect('delete-event', lambda w,e: act_quit())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_new())
add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_resume_all())
add_key_binding(win_main, '<Control>k', lambda a,b,c,d: act_pause_all())
add_key_binding(win_main, '<Control>l', lambda a,b,c,d: act_on_selection(act_show_log, 1))
add_key_binding(win_main, '<Control>p', lambda a,b,c,d: act_on_selection(act_props, 1))
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_options())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())

toolbuttons = [
	(None, 
		StockMenuToolButton(stock=gtk.STOCK_NEW,
			menuitems=[
				(gtk.STOCK_DIRECTORY, _("New Folder"), lambda x: act_new_folder()),
			]),
		None, act_new),
	(None, None, None, 'separator'),
	(_("Resume"), gtk.STOCK_MEDIA_PLAY, None, (act_on_selection, act_start)),
	(_("Pause"), gtk.STOCK_MEDIA_PAUSE, None, (act_on_selection, act_pause)),
	(_("Clear"), gtk.STOCK_CLEAR, None, (act_on_selection, act_clear_download)),
	(None, gtk.STOCK_PROPERTIES, None, (act_on_selection, act_props)),
	(None, None, None, 'separator'),
	(_("Select Completed"), 
		StockMenuToolButton(stock=gtk.STOCK_SELECT_ALL, 
			menuitems=[
				(gtk.STOCK_MEDIA_PLAY, _("Resume All"), lambda x: act_resume_all()),
				(gtk.STOCK_MEDIA_PAUSE, _("Pause All"), lambda x: act_pause_all()),
				gtk.SeparatorMenuItem(),
				(gtk.STOCK_ZOOM_IN, _("Expand All"), lambda x: act_expand_all()),
				(gtk.STOCK_ZOOM_OUT, _("Collapse All"), lambda x: act_collapse_all()),
			]),
		None, act_select_completed),
	(None, None, None, 'space'),
	(None, gtk.STOCK_PREFERENCES, None, act_options),
	(None, gtk.STOCK_QUIT, None, act_quit),
]
# TODO btn_remove
x, x_, btn_resume, btn_pause, btn_clear, btn_props, x_, x, x__, x, x \
= load_toolitems(main_toolbar, toolbuttons)

on_selection_change(main_selection)


tvc0 = gtk.TreeViewColumn(_("Filename"))
tvc0.set_resizable(True)
tvc0.set_sort_column_id(COL_NAME)
tvc0.set_sort_indicator(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
cr_txt.connect('editing-started', treeview_column0_editing)
cr_txt.connect('editing-canceled', treeview_column0_edit_canceled)
cr_txt.connect('edited', treeview_column0_edited)
tvc0.pack_start(cr_pix, False)
tvc0.pack_start(cr_txt, True)
tvc0.add_attribute(cr_txt, 'text', COL_NAME)
tvc0.add_attribute(cr_txt, 'editable', COL_NAMEEDITABLE)
tvc0.add_attribute(cr_pix, 'icon-name', COL_FILE_ICON)
tvc0.add_attribute(cr_pix, 'pixbuf', COL_PXB)
main_list.append_column(tvc0)
tvc = gtk.TreeViewColumn(_("Progress"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_PERCENT)
tvc.set_sort_indicator(True)
cr_prc = gtk.CellRendererProgress()
tvc.pack_start(cr_prc, True)
tvc.add_attribute(cr_prc, 'text', COL_PRCSTR)
tvc.add_attribute(cr_prc, 'value', COL_PERCENT)
tvc.add_attribute(cr_prc, 'pulse', COL_PULSE)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Status"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_STATUS)
tvc.set_sort_indicator(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_STATUS)
tvc.add_attribute(cr_pix, 'icon-name', COL_STATUS_ICON)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Speed"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_SPEED_BPS)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_SPEED_STR)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Added"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_ADDED_TSTMP)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_ADDED_DATE)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("ETA"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_ETA_SEC)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_ETA_STR)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Message"))
tvc.set_sort_column_id(COL_MESSAGE)
tvc.set_sort_indicator(True)
tvc.set_resizable(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'markup', COL_MESSAGE)
main_list.append_column(tvc)

main_list.set_rules_hint(True)
DownLoadList.set_sort_column_id(COL_ADDED_TSTMP, gtk.SORT_DESCENDING)
# TODO disorder ability
main_list.set_reorderable(True)
main_list.set_enable_search(True)
main_list.set_search_column(COL_NAME)
main_list.connect('button-press-event', on_treeview_click)
main_list.connect('key-press-event', on_treeview_key)
main_list.drag_dest_set(0, [], 0)
main_list.connect('drag-motion', DnD_motion)
main_list.connect('drag-drop', DnD_accept)
main_list.connect('drag-data-received', DnD_receive)
# TODO multi DnD
main_selection.set_mode(gtk.SELECTION_MULTIPLE)
main_selection.connect('changed', on_selection_change)
cmi_open_file.connect('activate', on_context_menu, act_open_file)
cmi_open_folder.connect('activate', on_context_menu, act_open_folder)
cmi_open_referer.connect('activate', on_context_menu, act_open_referer)
cmi_open_clipboard.connect('activate', on_context_menu, act_open_clipboard)
cmi_remove.connect('activate', on_context_menu, act_remove_download)
cmi_refetch.connect('activate', on_context_menu, act_refetch)
cmi_resume.connect('activate', on_context_menu, act_start)
cmi_pause.connect('activate', on_context_menu, act_pause)
cmi_clear.connect('activate', on_context_menu, act_clear_download)
cmi_log.connect('activate', on_context_menu, act_show_log)
cmi_props.connect('activate', on_context_menu, act_props)
fcmi_select.connect('activate', on_level_context_menu, act_select)
fcmi_remove.connect('activate', on_level_context_menu, act_remove_download)
fcmi_refetch.connect('activate', on_level_context_menu, act_refetch)
fcmi_resume.connect('activate', on_level_context_menu, act_resume)
fcmi_pause.connect('activate', on_level_context_menu, act_pause)
fcmi_clear.connect('activate', on_level_context_menu, act_clear_download)


# Pack main window's widgets
win_main.add(box_main)
box_main.pack_start(main_toolbar, 0, 1)
box_main.pack_start(scroller, 1, 1)
scroller.add_with_viewport(main_list)
scroller.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
ContextMenu.append(cmi_open)
cmi_open.set_submenu(ContextMenuOpen)
ContextMenuOpen.append(cmi_open_file)
ContextMenuOpen.append(cmi_open_folder)
ContextMenuOpen.append(cmi_open_referer)
ContextMenuOpen.append(cmi_open_clipboard)
ContextMenu.append(cmi_remove)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_refetch)
ContextMenu.append(cmi_resume)
ContextMenu.append(cmi_pause)
ContextMenu.append(cmi_clear)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_log)
ContextMenu.append(cmi_props)
ContextMenu.show_all()
FolderContextMenu.append(fcmi_select)
FolderContextMenu.append(gtk.SeparatorMenuItem())
FolderContextMenu.append(fcmi_remove)
FolderContextMenu.append(fcmi_refetch)
FolderContextMenu.append(fcmi_resume)
FolderContextMenu.append(fcmi_pause)
FolderContextMenu.append(fcmi_clear)
FolderContextMenu.show_all()


## New Download window

# Declare new download window's widgets
win_newdl = gtk.Window()
box_newdl = gtk.VBox()
note = gtk.Notebook()
page1 = gtk.VBox()
p1x1 = gtk.HBox()
p1l1 = gtk.Label(_("URLs"))
p1t1 = ScrolledTextView()
p1e1 = LabelledEntry(label=_("Rename to"), tooltip=_("Left empty to use filename provided by server/wget"))
p1c1 = FileChooserEntry(label=_("Target Folder"), path=LastFolder, action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
p1x2 = gtk.HBox(spacing=2)
p1l2a = gtk.Label(_("Bandwidth limit"))
p1a2 = gtk.Adjustment(value=0, lower=0, upper=gobject.constants.G_MAXINT, step_incr=1, page_incr=10)
p1s2 = gtk.SpinButton(p1a2)
p1l2b = gtk.Label()
page2 = gtk.VBox()
p2x1 = gtk.VBox()
p2c1 = FileChooserEntry(label=_("Cookie file"), action=gtk.FILE_CHOOSER_ACTION_OPEN)
p2l1 = gtk.Label(_("Custom Cookies per line in NAME=VALUE format:"))
p2t1 = ScrolledTextView()
page3 = gtk.VBox()
p3l1 = gtk.Label(_("POST parameters per line in NAME=VALUE format:\nURL encoding is not necessary"))
p3t1 = ScrolledTextView()
page4 = gtk.VBox()
p4x1 = gtk.HBox(spacing=2)
p4l1a = gtk.Label(_("Attempts"))
p4a1 = gtk.Adjustment(value=1, lower=0, upper=gobject.constants.G_MAXINT, step_incr=1, page_incr=10)
p4s1 = gtk.SpinButton(p4a1)
p4l1b = gtk.Label()
p4e2 = LabelledEntry(label=_("Username"))
p4e3 = LabelledEntry(label=_("Password"))
p4e4 = LabelledEntry(label=_("Proxy URL"))
p4e5 = LabelledEntry(label=_("Referer"))
p4e6 = LabelledEntry(label=_("User Agent"))
p4c1 = gtk.CheckButton(label=_("Content-Disposition filename"))
p4e7 = LabelledEntry(label=_("Custom options"), tooltip=_("type further options for wget\nsee 'wget --help' or 'man wget'"))
p4e8 = LabelledEntry(label=_("Run on complete"), tooltip=_("type a shell command-line\npair of curly brackets are substituted with downloaded file name\nexample: xdg-open {} && rm {}"))
btns_newdl = gtk.HBox(spacing=5)
btn_new_save = StockButton(label=_("Download"), stock=gtk.STOCK_SAVE, tooltip='Ctrl-Enter')
btn_new_open = StockButton(stock=gtk.STOCK_OPEN)
btn_new_queue = StockButton(label=_("Queue"), stock=gtk.STOCK_ADD, tooltip='Ctrl-Shift-Enter')
btn_new_no = StockButton(stock=gtk.STOCK_CANCEL, tooltip='Esc')

# Configure new download window's widgets
win_newdl.set_transient_for(win_main)
win_newdl.set_modal(True)
win_newdl.set_title(_("New Download"))
win_newdl.set_icon_name('emblem-downloads')
win_newdl.connect('delete-event', lambda w,e: w.hide() or True)
add_key_binding(win_newdl, 'Escape', lambda a,b,c,d: win_newdl.hide() or True)
add_key_binding(win_newdl, '<Control>Return', lambda a,b,c,d: new_download() or True)
add_key_binding(win_newdl, '<Control><Shift>Return', lambda a,b,c,d: new_download(start=False) or True)
for spinner in p1s2, p4s1:
	spinner.set_numeric(True)
	spinner.set_alignment(1.0)
p1t1.get_buffer().connect('changed', on_urls_edited)
p1l2b.set_markup(_("kB/s <small><i>(0 = unlimited)</i></small>"))
p4l1b.set_markup(_("<small><i>(0 = infinite)</i></small>"))
p4e3.set_visibility(False)
p4c1.set_tooltip_text(_("wget parses Content-Disposition header for filename"))
btns_newdl.set_border_width(5)
btn_new_save.connect('clicked', lambda b: new_download())
btn_new_open.connect('clicked', lambda b: new_download(doOpen=True))
btn_new_queue.connect('clicked', lambda b: new_download(start=False))
btn_new_no.connect('clicked', lambda b: win_newdl.hide() or True)




ParamDispatcherExtends = {
	'--directory-prefix': (p1c1,\
		lambda a: a if a!='' else os.getcwd(),\
		None),
	'rename_to': (p1e1,\
		lambda a, w: a if w.get_visible() else None,\
		None),
	'--limit-rate': (p1s2,\
		lambda a: '%dk' % (a,),\
		lambda b: convert_to_bytes(b, 'k')),
	'--load-cookies': (p2c1, None, None),
	'header_cookies': (p2t1,\
		lambda a: '; '.join(filter(lambda k: len(k), a.split('\n'))) if len(a.strip()) else None,\
		lambda b: '\n'.join(k.strip() for k in b.split(';'))+'\n'),
	'--post-data': (p3t1,\
		lambda a: urllib.urlencode(dict(map(lambda p: (p if p.find('=')>-1 else p+'=').split('=', 1), filter(lambda p: len(p), a.split('\n'))))),\
		lambda b: '\n'.join(urllib.unquote(p) for p in b.split('&'))+'\n'),
	'--tries': (p4s1, None, None),
	'--user': (p4e2, None, None),
	'--password': (p4e3, None, None),
	'proxy': (p4e4, None, None),
	'--referer': (p4e5, None, None),
	'--user-agent': (p4e6, None, None),
	'--content-disposition': (p4c1, None, None),
	'': (p4e7,\
		lambda a: a.split(),\
		lambda b: ' '.join(b)),
	'on_complete': (p4e8, None, None),
}
# Map short wget options to long ones.
ShortLongOptions = {
	'-P': '--directory-prefix',
	'-t': '--tries',
	'-U': '--user-agent',
}
# Map gwget cli options to ParamDispatcher keys.
GWgetOptionsParam = {
	'--proxy-url': 'proxy',
	'--cookies': 'header_cookies',
	'--rename-to': 'rename_to',
	'--output-document': 'rename_to',
	'--run-on-complete': 'on_complete',
	'--cwd-prefix': '--directory-prefix',
}
for wdg, dflt in (p1s2, 0), (p4s1, 1), (p4c1, True):
	wdg.set_data('default-value', dflt)
ParamDispatchers = {}
for opt, (wdg, getter, putter) in ParamDispatcherExtends.iteritems():
	pd = ParamDispatcher(wdg, optname=opt)
	if getter: pd.set_getter(getter)
	if putter: pd.set_putter(putter)
	ParamDispatchers[opt] = pd


# Pack new download window's widgets
win_newdl.add(box_newdl)
box_newdl.pack_start(note, 1, 1)
note.append_page(page1, gtk.Label(_("Basic")))
page1.pack_start(p1x1, 1, 1)
p1x1.pack_start(p1l1, 0, 1)
p1x1.pack_start(p1t1, 1, 1)
page1.pack_start(p1e1, 0, 1)
page1.pack_start(p1c1, 0, 1)
page1.pack_start(p1x2, 0, 1)
p1x2.pack_start(p1l2a, 0, 1)
p1x2.pack_start(p1s2, 0, 1)
p1x2.pack_start(p1l2b, 0, 1)
note.append_page(page2, gtk.Label(_("Cookies")))
page2.pack_start(p2x1, 1, 1)
p2x1.pack_start(p2c1, 0, 1)
p2x1.pack_start(p2l1, 0, 1)
p2x1.pack_start(p2t1, 1, 1)
note.append_page(page3, gtk.Label(_("POST")))
page3.pack_start(p3l1, 0, 0)
page3.pack_start(p3t1, 1, 1)
note.append_page(page4, gtk.Label(_("Advanced")))
page4.pack_start(p4x1, 0, 1)
p4x1.pack_start(p4l1a, 0, 1)
p4x1.pack_start(p4s1, 0, 1)
p4x1.pack_start(p4l1b, 0, 1)
page4.pack_start(p4e2, 0, 1)
page4.pack_start(p4e3, 0, 1)
page4.pack_start(p4e4, 0, 1)
page4.pack_start(p4e5, 0, 1)
page4.pack_start(p4e6, 0, 1)
page4.pack_start(p4c1, 0, 1)
page4.pack_start(p4e7, 0, 1)
page4.pack_start(p4e8, 0, 1)
box_newdl.pack_start(btns_newdl, 0, 0)
btns_newdl.pack_start(btn_new_save, 0, 1)
btns_newdl.pack_start(btn_new_open, 0, 1)
btns_newdl.pack_start(btn_new_queue, 0, 1)
btns_newdl.pack_start(btn_new_no, 0, 1)

for label in p1l1, p2l1, p1l2a, p1l2b, p3l1, p4l1a, p4l1b:
	label.set_alignment(0, 0)
	label.set_padding(4, 5)



win_newdl.show_all()
win_newdl.hide()
win_main.show_all()
dbus_service = GwgetService(win_main)
gtk.main()
