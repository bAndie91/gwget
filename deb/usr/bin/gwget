#!/usr/bin/env python2.7
# -*- coding: UTF-8 -*-

import os
import sys
import signal
import select
import fcntl
import re
import time


PROGNAME = 'gwget'
APPNAME = 'hu.uucp.gwget'

if any(flag in sys.argv for flag in ['-h', '--help']):
	print """Usage: %s [gwget options] [wget options] [URLs...]
%s options:
  --proxy-url URL
  --cookies NAME=VALUE[;NAME=VALUE[;...]]
  --cwd-prefix
  --rename-to FILENAME
  --run-on-complete COMMAND""" % (PROGNAME, PROGNAME)
	raise SystemExit(0)


import dbus
import dbus.service
import dbus.glib
import gettext
import setproctitle
import resource

import glib
import gobject
import gio
import gtk
import pango
import threading

import pickle
import traceback
import functools
import inspect

import glob
import base64
import urllib
import urlparse
try:
 import xattr
except ImportError:
 xattr = None
from mimetypes import guess_extension
import magic


# Functions and Subroutines

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def display_error(e, isPango=False, gtkErrorLevel=gtk.MESSAGE_ERROR):
	if threading.currentThread().name != 'MainThread':
		gtk.threads_enter()
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		if hasattr(e, 'filename'):
			if e.filename:
				files = e.filename
			else:
				files = '; '.join(e.filenames or [])
			files = '\n' + files
		else:
			files = ''
		text = '%s%s%s (%d)%s' % (e.message, e.message and '\n', e.strerror, e.errno, files)
	elif isinstance(e, Exception):
		text = e.message
		if hasattr(e, 'errno'):
			text += ' (%d)' % e.errno
	elif type(e) == list:
		text = '\n'.join(e)
	elif type(e) in [str, int]:
		text = str(e)
	if text is None:
		text = repr(e)
	if isinstance(e, BaseException):
		classname = e.__class__.__name__
		if not e.__class__.__module__.startswith('_'):
			classname = e.__class__.__module__ + '.' + classname
		text = classname + ':\n' + text
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtkErrorLevel, gtk.BUTTONS_OK, '' if isPango else text)
	if isPango: dlg.set_markup(text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()
	if threading.currentThread().name != 'MainThread':
		gtk.threads_leave()

class DialogCancel(Exception):
	pass

def question(msg, parent=None, yes=None, no=None, cancelable=False, default=gtk.RESPONSE_YES):
	dlg = gtk.MessageDialog(parent, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_NONE)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if yes is None:
		dlg.add_buttons(gtk.STOCK_YES, gtk.RESPONSE_YES)
	else:
		if type(yes) in [type(()), type([])]:
			btn_yes = StockButton(label=yes[0], stock=yes[1])
			dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
			btn_yes.show()
		else:
			dlg.add_buttons(yes, gtk.RESPONSE_YES)
	if no is None:
		dlg.add_buttons(gtk.STOCK_NO, gtk.RESPONSE_NO)
	else:
		if type(no) in [type(()), type([])]:
			btn_no = StockButton(label=no[0], stock=no[1])
			dlg.add_action_widget(btn_no, gtk.RESPONSE_NO)
			btn_no.show()
		else:
			dlg.add_buttons(no, gtk.RESPONSE_NO)
	if cancelable:
		dlg.add_buttons(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
		add_key_binding(dlg, 'Escape', lambda a,b,c,d: dlg.response(gtk.RESPONSE_CANCEL) or True)
	dlg.set_default_response(default)
	resp = dlg.run()
	dlg.destroy()
	if resp == gtk.RESPONSE_CANCEL:
		raise DialogCancel()
	return (resp == gtk.RESPONSE_YES)

def set_dialog_icon_name(dlg, icon):
	img = dlg.get_content_area().children()[0].children()[0]
	img.set_from_icon_name(icon, gtk.ICON_SIZE_DIALOG)

def create_choose_dialog(action, path=None, init=None):
	btn_accept_stock = gtk.STOCK_OPEN
	if action in [gtk.FILE_CHOOSER_ACTION_SAVE, gtk.FILE_CHOOSER_ACTION_CREATE_FOLDER]:
		btn_accept_stock = gtk.STOCK_SAVE
	dlg = gtk.FileChooserDialog(parent=None, action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	
	if action in [gtk.FILE_CHOOSER_ACTION_OPEN, gtk.FILE_CHOOSER_ACTION_SAVE] and path is not None:
		dlg.set_filename(path)
	else:
		dlg.set_current_folder(path or LastFolder)
	if init is not None:
		dlg.set_current_name(init)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	return dlg

def choose_dialog(action, path=None, init=None):
	selected = None
	dlg = create_choose_dialog(action, path=path, init=init)
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			# 'Working Dir' button
			dlg.set_current_folder(os.getcwd())
		else:
			break
	global LastFolder
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None, init=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename=filename, init=init)

def choose_folder(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, folder=folder)

def choose_open_file(folder=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN, folder=folder)

class FileEntryCompletion(gtk.EntryCompletion):
	def __init__(self, entry, actiontype=gtk.FILE_CHOOSER_ACTION_OPEN):
		assert(isinstance(entry, gtk.Entry))
		super(self.__class__, self).__init__()
		self.set_popup_completion(True)
		self.set_popup_set_width(True)
		self.model = gtk.ListStore(str, str)
		self.set_model(self.model)
		self.set_text_column(1)
		self.set_match_func(self.match, 0)
		self.connect('match-selected', self.selected)
		entry.set_completion(self)
		entry.connect('changed', self.edited)
		self.actiontype = actiontype
		self.entry = entry
	def edited(self, entry):
		olddir = entry.get_data('saved-dirname')
		curdir = os.path.dirname(entry.get_text())
		if olddir != curdir:
			entry.set_data('saved-dirname', curdir)
			self.model.clear()
			try:
				for f in sorted(os.listdir(curdir)):
					p = os.path.join(curdir, f)
					if os.path.isdir(p):
						p += '/'
						f += '/'
					elif self.actiontype in [gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER, gtk.FILE_CHOOSER_ACTION_CREATE_FOLDER]:
						continue
					self.model.append([p, f])
			except OSError:
				entry.set_data('saved-dirname', None)
	def match(self, compl, key, itr, keycol):
		key = self.entry.get_text()
		text = self.model.get_value(itr, keycol)
		if text is not None:
			return self.model.get_value(itr, keycol).startswith(key)
		return False
	def selected(self, compl, model, itr):
		self.entry.set_text(model.get_value(itr, 0))
		self.entry.select_region(-1, -1)
		return True

class FileChooserEntry(gtk.HBox):
	def __init__(self, label='', path='', action=gtk.FILE_CHOOSER_ACTION_OPEN):
		super(self.__class__, self).__init__(spacing=2)
		self.Label = gtk.Label(label)
		self.Label.set_alignment(0, 0)
		self.Label.set_padding(2, 8)
		self.Entry = gtk.Entry()
		self.Entry.set_text(path)
		self.pathcompleter = FileEntryCompletion(self.Entry, action)
		self.Button = StockButton(label='', stock=gtk.STOCK_OPEN, icon_size=gtk.ICON_SIZE_MENU)
		self.Button.connect('clicked', self.choose, action)
		self.pack_start(self.Label, 0, 0)
		self.pack_start(self.Entry, 1, 1)
		self.MenuBtn = gtk.MenuToolButton(None, None)
		self.MenuBtn.children()[0].remove(self.MenuBtn.children()[0].children()[0])
		self.pack_start(self.MenuBtn, 0, 0)
		self.pack_start(self.Button, 0, 0)
	def get_text(self):
		return self.Entry.get_text()
	def set_text(self, text):
		ent = self.Entry
		ent.set_text(text)
		ent.select_region(-1, -1)
	def get_label(self):
		return self.Label.get_text()
	def set_label(self, text):
		return self.Label.set_text(text)
	def choose(self, btn, action):
		p = choose_dialog(action, path=self.Entry.get_text())
		if p is not None:
			self.set_text(p)
	def set_history(self, items):
		historymenu = self.MenuBtn.get_menu()
		if historymenu is None:
			historymenu = gtk.Menu()
			self.MenuBtn.set_menu(historymenu)
		for menuitem in historymenu.get_children():
			historymenu.remove(menuitem)
		for label in items:
			menuitem = gtk.MenuItem(label, use_underline=False)
			menuitem.connect('activate', lambda mi: self.set_text(mi.get_label()))
			historymenu.append(menuitem)
		historymenu.show_all()

class ScrolledTextView(gtk.ScrolledWindow):
	def __init__(self):
		super(self.__class__, self).__init__()
		self.TextView = gtk.TextView()
		self.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.set_shadow_type(gtk.SHADOW_IN)
		self.add(self.TextView)
		self.TextView.set_editable(True)
		self.TextView.set_accepts_tab(False)
		self.TextView.set_wrap_mode(gtk.WRAP_NONE)
		self.TextView.modify_font(pango.FontDescription('monospace'))
		for attr, val in gtk.TextView.__dict__.iteritems():
			# make TextView class methods inherited
			if not attr.startswith('_') and not hasattr(self, attr) and callable(val):
				self.__dict__[attr] = functools.partial(val, self.TextView)
	def get_text(self):
		bufr = self.TextView.get_buffer()
		return bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True)
	def set_text(self, text):
		bufr = self.TextView.get_buffer()
		return bufr.set_text(text)
	def grab_focus(self):
		return self.TextView.grab_focus()
	def get_textview(self):
		return self.TextView

class LabelledEntry(gtk.HBox):
	def __init__(self, label='', markup=None, tooltip=None, spacing=2):
		super(self.__class__, self).__init__(spacing=spacing)
		self.Label = gtk.Label(label)
		self.Entry = gtk.Entry()
		self.Label.set_alignment(0, 0)
		self.Label.set_padding(4, 5)
		if markup is not None:
			self.Label.set_markup(markup)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
		self.pack_start(self.Label, 0, 1)
		self.pack_start(self.Entry, 1, 1)
		for cname in 'Entry', 'Label':
			for attr, val in getattr(gtk, cname).__dict__.iteritems():
				if not attr.startswith('_') and not hasattr(self, attr) and callable(val):
					self.__dict__[attr] = functools.partial(val, getattr(self, cname))


def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None, tooltip=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_markup(self, markup):
		x, lbl = self.__get_children()
		lbl.set_markup(markup)

def SetAnyIcon(name, widget):
	size = gtk.ICON_SIZE_MENU
	def find_path(name):
		dit = gtk.icon_theme_get_default()
		for d1 in dit.get_search_path():
			for d2 in ['hicolor', 'locolor']:
				sizedirs = ['16x16', 'scalable']
				try:
					sizedirs.extend(os.listdir(os.path.join(d1,d2)))
				except OSError:
					continue
				for d3 in sizedirs:
					for ext in ['png', 'xpm', 'svg']:
						p = os.path.join(d1,d2,d3,name+'.'+ext)
						if os.path.exists(p):
							return p
		raise Exception("Icon not found: '%s'" % name)
	
	if name in gtk.stock_list_ids():
		aux = gtk.ImageMenuItem(stock_id=name)
		img = aux.get_image()
	else:
		dit = gtk.icon_theme_get_default()
		img = gtk.Image()
		if dit.has_icon(name):
			pxb = dit.load_icon(name, size, 0)
			img.set_from_pixbuf(pxb)
		else:
			try:
				iconpath = find_path(name)
				img.set_from_file(iconpath)
			except:
				pass
	widget.set_image(img)

class StockMenuItem(gtk.ImageMenuItem):
	def __init__(self, label=None, stock_id=None, accel_group=None):
		gtk.ImageMenuItem.__init__(self, stock_id, accel_group)
		if stock_id not in gtk.stock_list_ids():
			SetAnyIcon(stock_id, self)
		if label is not None:
			self.set_label(label)

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left in toolitems:
		hid = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(_(tip))
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		else:
			Lstocklabel = None
			st = gtk.stock_lookup(stock)
			if st:
				Lstocklabel = re.sub('_', '', st[1])
			if label is not None:
				Llabel = _(label)
			else:
				Llabel = Lstocklabel
			if tip is not None:
				Ltip = _(tip)
			else:
				if label is not None:
					Ltip = Llabel
				else:
					Ltip = Lstocklabel
			tbi = StockToolButton(label=Llabel, stock=stock, tooltip=Ltip)
			tbi.set_data('stock', stock)
			tbi.set_data('label', label)
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

def str_accurate_at_time(ts):
	HOUR = 60 * 60
	DAY = 24 * HOUR
	WEEK = 7 * DAY
	YEAR = 365 * DAY
	
	ts0 = time.time()
	age = ts0 - ts
	then = time.localtime(ts)
	if age < YEAR:
		if age < 4 * WEEK:
			if age < DAY:
				fmt = '%H:%M'
			else:
				fmt = '%d, %a'
		else:
			fmt = '%b %d'
	else:
		fmt = '%Y %b'
	return time.strftime(fmt, then)

## OS functions

def mkdir(d):
	p = os.path.dirname(d)
	if not os.path.exists(p):
		mkdir(p)
	try:
		os.mkdir(d)
	except OSError as e:
		if e.errno != os.errno.EEXIST:
			raise e

def stderr(s):
	sys.stderr.write(s)

def delete(f, warn=True):
	try:
		os.unlink(f)
	except OSError as e:
		if warn:
			stderr('%s: error %d: %s\n' % (e.filename, e.errno, e.strerror))
		if e.errno != os.errno.ENOENT:
			display_error(e)
			return False
	return True

def relative_path(target, start=None):
	if start is None:
		start = os.getcwd()
	return os.path.relpath(target, os.path.realpath(start))

class PropertyStore(object):
	pass

class ShellCommandException(Exception):
	pass

def run_synchronous(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	outreader, outwriter = os.pipe()
	errreader, errwriter = os.pipe()
	pid = os.fork()
	if pid == 0:
		os.close(outreader)
		os.close(errreader)
		os.dup2(outwriter, sys.stdout.fileno())
		os.dup2(errwriter, sys.stderr.fileno())
		sys.stdin.close()
		os.closerange(3, OSMaxFiles)
		try: os.execvp(cmd, args)
		except OSError as e: print e.message
		os._exit(127)
	
	os.close(outwriter)
	os.close(errwriter)
	outreader = os.fdopen(outreader, 'r')
	errreader = os.fdopen(errreader, 'r')
	cmd = PropertyStore()
	cmd.stdout = ''
	cmd.stderr = ''
	fds = [outreader, errreader]
	while len(fds) > 0:
		ready = select.select(fds, [], [], 2.0)
		for fd in ready[0]:
			line = fd.readline()
			if line == '':
				fd.close()
				fds.remove(fd)
			else:
				if fd == outreader:
					cmd.stdout += line
				elif fd == errreader:
					cmd.stderr += line
	x, cmd.status = os.waitpid(pid, 0)
	cmd.exitcode = cmd.status >> 8
	cmd.signal = cmd.status & 0x7F
	cmd.coredump = cmd.status & 0x80 >> 7
	#print cmd.__dict__
	return cmd

def run_detached(cmd, args):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, OSMaxFiles)
		pid2 = os.fork()
		if pid2 == 0:
			try:
				os.execvp(cmd, args)
			except OSError:
				pass
			os._exit(127)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

class Readlines(object):
	def __init__(self, handle):
		self.handle = handle
	def __iter__(self):
		return self
	def next(self):
		s = self.handle.readline()
		if s == '':
			raise StopIteration
		return s
	def __del__(self):
		pass

def prepend_uniq(array, item):
	while item in array: array.remove(item)
	array.insert(0, item)

def convert_to_bytes(s, p='b'):
	prefix = {'b': 1, 'k': 1024, 'm': 1024**2, 'g': 1024**3, 't': 1024**4, 'p': 1024**5,}
	m = re.search('(.+?)([a-z]?)$', s, re.IGNORECASE)
	b = float(m.group(1)) * prefix[m.group(2).lower() or 'b']
	return b / prefix[p]

def set_xattrs_file(filename, attrs):
	fh = open(filename, 'r')
	try:
		set_xattrs(fh, attrs, filename)
	except:
		raise
	finally:
		fh.close()

def set_xattrs(fh, attrs, filename='-'):
	if xattr is not None:
		for attrname, attrval in attrs.iteritems():
			try:
				if attrval is None:
					try:
						xattr.removexattr(fh, attrname)
					except IOError as e:
						if e.errno != os.errno.ENODATA:
							raise e
				else:
					xattr.setxattr(fh, attrname, attrval)
			except IOError as e:
				stderr(_("Notice: can not set xattr '%s' on '%s': %s\n") % (attrname, filename, str(e)))

if not hasattr(glob, 'escape'):
	def glob_escape(s):
		for c in '[*?':
			s = s.replace(c, '['+c+']')
		return s
	glob.escape = glob_escape

def next_file_number(preglob, sufglob, n=1):
	while True:
		wildcard = preglob + str(n) + sufglob
		if not glob.glob(wildcard): break
		n += 1
	return n

if hasattr(magic, 'open'):
	mime_magic = magic.open(magic.MAGIC_MIME_TYPE)
	mime_magic.load()

def guess_mime(path):
	if hasattr(magic, 'open'):
		typ = mime_magic.file(path)
	else:
		typ = magic.from_file(path, mime=True)
	if typ is not None and not re.match('[a-z0-9_+-]+/[a-z0-9_+-]+$', typ): typ = None
	return typ

### Private methods ###

class BaseDownload(object):
	def __init__(self, url, params={}):
		self.added_ts = time.time()
		self.logfile = next_logfile()
		self.original_url = url
		self.params = params
		self.outfile = None
		self.Lock = threading.Lock()
	def morior(self):
		delattr(self, 'Lock')
	def resurgo(self):
		self.Lock = threading.Lock()
	def configure(self, attrs, items):
		for k, v in attrs.iteritems():
			setattr(self, k, v)
	def __getitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			out = getattr(self, '_' + key)
			self.Lock.release()
			return out
		else:
			self.Lock.release()
			raise KeyError()
	def __delitem__(self, key):
		self.Lock.acquire(True)
		if hasattr(self, '_' + key):
			delattr(self, '_' + key)
		self.Lock.release()
	def __setitem__(self, key, val):
		self.Lock.acquire(True)
		setattr(self, '_' + key, val)
		self.Lock.release()
		return True
	def get_dumpfile(self):
		return self.logfile[:-3] + 'obj'
	def get_url(self):
		return self.original_url
	def init(self):
		self['status'] = S_QUEUE
		self.completed = False
		self.running = False
		self.size = None
		self.mime_remote = None
		self.mime_local = None
		self.charset = None
		self.percent = -1
		self.speed = 0
		self.speed_str = ''
		self.eta = -1
		self.eta_str = ''
		self.lastline = ''
	def mark_completed(self):
		self.completed = True
		self['status'] = S_SAVED
		self.eta = -1
		self.eta_str = ''
		if self.mime_local is None: self.set_mime_local()
		refresh_download_state(self)
		on_completed_download(self)
	def set_mime_local(self):
		self.mime_local = guess_mime(self.outfile)

class Download(BaseDownload):
	def __init__(self, url, params={}):
		super(self.__class__, self).__init__(url, params)
		self.actual_url = None
		self.progress_type = 'bar:force'
		#self.progress_type = 'dot:default'
		self._pid = None
		self.init()
	def resurgo(self):
		super(self.__class__, self).resurgo()
		if self.running:
			t2 = threading.Thread(target=self.watch_log, args=())
			t2.daemon = True
			t2.start()
	def __setitem__(self, key, val):
		self.Lock.acquire(True)
		if key == 'status' and hasattr(self, '_status'):
			# Do not change status S_STOP -> S_DL ; S_SAVED -> S_ERR ; S_STOP -> S_ERR ;
			if (self._status == S_STOP and val == S_DL) or (self._status in [S_SAVED, S_STOP] and val == S_ERR):
				self.Lock.release()
				return False
			if self._status == S_INIT and val == S_DL:
				# Set xAttributes when downloading just started
				try:
					setxattributes(self)
				except IOError as e:
					print e.message
		setattr(self, '_' + key, val)
		self.Lock.release()
		return True
	def get_url(self):
		return self.actual_url or self.original_url
	def spawn_wget(self, args=[]):
		reader, writer = os.pipe()
		pid = os.fork()
		if pid == 0:
			os.putenv('LANG', 'C')
			if self.params.has_key('proxy_url'):
				proxy = self.params['proxy_url']
				os.putenv('http_proxy', proxy)
				os.putenv('https_proxy', proxy)
				os.putenv('ftp_proxy', proxy)
			os.close(reader)
			os.dup2(writer, sys.stdout.fileno())
			os.dup2(writer, sys.stderr.fileno())
			sys.stdin.close()
			os.closerange(3, OSMaxFiles)
			try: os.execvp('wget', ['wget'] + args)
			except OSError as e: print e.message
			os._exit(127)
		os.close(writer)
		return os.fdopen(reader, 'r')
	def start(self):
		if self['pid'] is not None:
			return
		self.init()
		refresh_download_state(self)
		if os.path.exists(self.logfile):
			logfilename, logfiledotext = os.path.splitext(self.logfile)
			savelogfile = '%s_%d%s' % (logfilename, next_file_number(logfilename+'_', logfiledotext, 2), logfiledotext)
			try:
				os.rename(self.logfile, savelogfile)
			except OSError, e:
				# Treat this not a serious error.
				stderr(e.message + '\n')
		
		wget_args = ParamDispatcher.convert_to_wget_args(self.params)
		wget_args += ['--verbose', '--output-file', self.logfile,\
		  '--background', '--continue', '--progress', self.progress_type,\
		  '--adjust-extension', '--retry-connrefused',\
		  '--auth-no-challenge']
		wget_args.append(self.original_url)
		try:
			readhandle = self.spawn_wget(wget_args)
		except OSError as e:
			display_error(e)
			return
		
		self['status'] = S_INIT
		refresh_download_state(self)
		t1 = threading.Thread(target=self.watch_output, args=(readhandle,))
		t1.daemon = True
		t1.start()
	def wget_running(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], 0)
				return True
			except OSError:
				pass
		return False
	def watch_output(self, readhandle):
		for line in Readlines(readhandle):
			stderr(line)
			line = line.strip()
			if line != '':
				self.lastline = line
				m_pid = re.search('pid (\d+)', line)
				if m_pid:
					self['pid'] = int(m_pid.group(1))
				refresh_download_state(self)
		readhandle.close()
		if self['pid']:
			self.running = True
			t2 = threading.Thread(target=self.watch_log, args=())
			t2.daemon = True
			t2.start()
		else:
			self['status'] = S_ERR
		refresh_download_state(self)
	def watch_log(self):
		while not os.path.exists(self.logfile):
			time.sleep(1)
		fh = open(self.logfile, 'r')
		linebuffer = ''
		while True:
			data = fh.readline()
			if data == '':
				if self.wget_running():
					time.sleep(0.4)
					continue
				else:
					break
			
			line = linebuffer + data
			try: rline = line[line.rindex('\r')+1:]
			except ValueError: rline = line
			if line[-1] == '\n':
				linebuffer = ''
			else:
				linebuffer = rline
			line = rline.strip()
			if line == '':
				continue
			
			refresh = False
			m_length = re.search('^Length: (\d+)', line)
			m_mime = re.search('^Length:.*?\[(\S+?)\]', line)
			m_name1 = re.search('^Saving to: .(.+).$', line)
			m_name2 = re.search('^Server file no newer than local file .(.+). -- not retrieving\.$', line)
			m_percent = re.search('^\s{0,2}(\d+)(\.\d+)?%', line)
			m_progress = re.search('^\s*\[', line)
			m_speed = re.search('(\d+(?:\.\d+)?)(.)/s(?:\s+eta\s+(.+))?', line)
			m_kilodots = re.search('^\s*(\d+)K\s+([., ]*)', line)
			m_completed = re.search(' saved \S+$', line)
			m_redirect = re.search('^Location: (\S+)', line)
			
			if m_length:
				self.size = int(m_length.group(1))
			if m_mime:
				self.mime_remote = m_mime.group(1)
			if m_name1:
				self.outfile = m_name1.group(1).decode('string-escape')
				refresh = True
			if m_name2:
				self.outfile = m_name2.group(1).decode('string-escape')
				self.completed = True
				self.eta = -1
				self.eta_str = ''
				refresh = True
			if m_percent:
				self.percent = int(m_percent.group(1))
				self['status'] = S_DL
				refresh = True
			if m_progress:
				pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_speed:
				self.speed_str = m_speed.group(1) + m_speed.group(2) + '/s'
				self.speed = convert_to_bytes(m_speed.group(1) + m_speed.group(2))
				if m_speed.group(3) is not None:
					self.eta_str = m_speed.group(3)
					eta = 0
					for u, q in ('d', 24*60*60), ('h', 60*60), ('m', 60), ('s', 1):
						m = re.search('(\d+)'+u, m_speed.group(3))
						if m: eta += int(m.group(1)) * q
					self.eta = eta
				refresh = True
			if m_kilodots:
				if self.size is not None:
					kilo = int(m_kilodots.group(1))
					dots = len(''.join(m_kilodots.group(2).split()))
					self.percent = int((kilo + dots) * 1024 * 100 / self.size)
				else:
					pulse_download(self['pid'])
				self['status'] = S_DL
				refresh = True
			if m_completed:
				self.mark_completed()
				refresh = True
			if m_redirect:
				self.actual_url = m_redirect.group(1)
				refresh = True
			
			if self.lastline != line:
				refresh = True
			self.lastline = line
			if refresh:
				refresh_download_state(self)
		fh.close()
		self.running = False
		self['status'] = S_ERR
		self['pid'] = None
		refresh_download_state(self)
		start_next_download(self)
	def stop(self):
		if self['pid'] is not None:
			try:
				os.kill(self['pid'], signal.SIGTERM)
				self['status'] = S_STOP
			except OSError as e:
				if e.errno != os.errno.ESRCH:
					raise e

class DataDownload(BaseDownload):
	Decoder = {
		'base64': base64.decodestring,
		'url': urllib.unquote,
	}
	def __init__(self, url, params={}):
		super(self.__class__, self).__init__(url, params)
		self.init()
	def get_url(self):
		return None
	def start(self):
		if self.completed or self.original_url is None:
			return False
		t1 = threading.Thread(target=self.worker)
		t1.daemon = True
		t1.start()
	def worker(self):
		self['status'] = S_INIT
		self.running = True
		try:
			encoding = 'url'
			try:
				m = re.match('^data:(?:([^,]*),)?(.*)', self.original_url)
				meta, data = m.groups()
				if meta is None: meta = ''
			except ValueError:
				raise Exception(_("Can not parse URL."))
			# Free memory:
			self.original_url = None
			for m in meta.split(';'):
				if m.startswith('charset='):
					self.charset = m[8:]
				elif re.match('.*/', m):
					self.mime_remote = m
				elif m in ['base64']:
					encoding = m
			
			directory = self.params['--directory-prefix']
			basename = 'data-'
			num = next_file_number(glob.escape(os.path.join(directory, basename)), '.*')
			ext = guess_extension(self.mime_remote or MIME_DEFAULT) or '.dat'
			filename = '%s%d%s' % (basename, num, ext)
			self.outfile = os.path.join(directory, filename)
			
			try:
				decoder = self.Decoder[encoding]
			except KeyError:
				raise Exception(_("Unknown encoding: %s" % (encoding)))
			try:
				fh = open(self.outfile, 'w')
				self['status'] = S_DL
				fh.write(decoder(data))
				self.size = fh.tell()
				fh.close()
				self.percent = 100
			except IOError as e:
				raise Exception(e)
			
			self.running = False
			self.mark_completed()
		except Exception as e:
			self['status'] = S_ERR
			self.running = False
			refresh_download_state(self)
			display_error(e)
	def stop(self):
		return False

def column_width_change(col, pspec):
	sid = col.get_data('signal-notify::width')
	w = col.get_property(pspec.name)
	col.set_data('reported-width', w)
	if not scroller.get_data('initial-column-resize'):
		if all(map(lambda col: col.get_data('reported-width'), main_list.get_columns())):
			scroller.set_data('initial-column-resize', True)
			for col in main_list.get_columns():
				col.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
				col.set_fixed_width(col.get_data('reported-width'))
			resize_column0()
			win_main.connect('configure-event', win_main_configure)
	if win_main.get_data('resized'):
		win_main.remove_data('resized')
		resize_column0()

def resize_column0():
	cols = main_list.get_columns()
	if all(map(lambda col: col.get_data('reported-width'), cols)):
		total = scroller.get_allocation().width
		midwidth = 0
		for col in cols[1:-1]:
			midwidth += col.get_data('reported-width')
		treeview_column_set_width(cols[0], total - midwidth - 24)

def treeview_column_set_width(col, width):
	col.set_data('column-width', width)
	if col.get_sizing() == gtk.TREE_VIEW_COLUMN_FIXED:
		col.set_fixed_width(width)
	else:
		col.set_min_width(width)
		col.set_max_width(width)
		glib.idle_add(lambda: (col.set_min_width(-1), col.set_max_width(-1)), priority=glib.PRIORITY_DEFAULT_IDLE)

def win_main_configure(win, evt):
	if win_main.get_data('saved-width') != evt.width or win_main.get_data('saved-height') != evt.height:
		win_main.set_data('resized', True)
		win_main.set_data('saved-width', evt.width)
		win_main.set_data('saved-height', evt.height)
		# Trigger column-width change:
		col0 = main_list.get_columns()[0]
		w = col0.get_data('column-width')
		treeview_column_set_width(col0, w+1)

def lock_row_refresh(doLock):
	main_list.set_data('refresh-lock', doLock)
	row = main_list.get_data('editing-row')
	if doLock:
		if row[COL_DLOBJ].running:
			QUESTIONMARKS = '???'
			row[COL_PRCSTR] = QUESTIONMARKS
			row[COL_SPEED_STR] = QUESTIONMARKS
			row[COL_STATUS_ICON] = StatusIcon[S_GUILOCK]
			row[COL_STATUS] = _(Status[S_GUILOCK])
			row[COL_ETA_STR] = QUESTIONMARKS
	else:
		refresh_download_state(row[COL_DLOBJ])

def treeview_column0_editing(cellrenderer, editable, rownum):
	row = DownLoadList[(int(rownum),)]
	main_list.set_data('editing-row', row)
	dl = row[COL_DLOBJ]
	if not os.path.exists(dl.outfile):
		row[COL_NAMEEDITABLE] = False
		return
	lock_row_refresh(True)

def treeview_column0_edited(cellrenderer, itpathstr, newtext):
	row = main_list.get_data('editing-row')
	dl = row[COL_DLOBJ]
	if dl.outfile:
		newpath = os.path.join(os.path.dirname(dl.outfile), newtext)
		if rename_downloaded_file(dl, newpath):
			dl.manually_renamed = True
			if os.path.isabs(newtext):
				dl.params['rename_to'] = newpath
			else:
				dl.params['rename_to'] = relative_path(newpath, dl.params['--directory-prefix'])
	lock_row_refresh(False)

def treeview_column0_edit_canceled(cellrenderer):
	lock_row_refresh(False)

def win_main_show():
	# Manage GUI
	btn_remove.hide()
	
	# Load cached downloads from object dumps
	import_downloads()
	
	# Add signals for each column
	for col in main_list.get_columns():
		sid = col.connect('notify::width', column_width_change)
		col.set_data('signal-notify::width', sid)
	
	# Start background thread
	continous_refresh_thread = threading.Thread(target=continous_refresh, args=(60,))
	continous_refresh_thread.daemon = True
	continous_refresh_thread.start()
	
	# Parse CLI args
	main_parse_cli(sys.argv)

def main_parse_cli(argv, append_url = False, cwd = None):
	cliURLs = []
	cliOpts = []
	idx = 1
	while idx < len(argv):
		arg = argv[idx]
		if arg.startswith('-'):
			m = re.search('([^=]+)=(.*)', arg)
			if m:
				key, val = m.group(1), m.group(2)
			else:
				key = arg
				val = None
				if key.startswith('--no-'):
					key = '--' + key[5:]
					val = False
				elif key not in ParameterlessOptions and idx+1 < len(argv):
					argnext = argv[idx+1]
					if not argnext.startswith('-'):
						val = argnext
						idx += 1
			cliOpts.append((key, val))
		else:
			cliURLs.append(arg)
		idx += 1
	
	# Setup New Download panel with URL(s) and options given in CLI.
	if cliURLs:
		if not win_newdl.props.visible:
			reset_parameters()
		params = {}
		for optnam, optval in cliOpts:
			if ShortLongOptions.has_key(optnam):
				optnam = ShortLongOptions[optnam]
			if optnam == '--cookies':
				# FIXME --cookies <=> --header
				optval = ['Cookie: ' + optval]
			elif optnam == '--cwd-prefix':
				optval = cwd or os.getcwd()
			if GWgetOptionsParam.has_key(optnam):
				optnam = GWgetOptionsParam[optnam]
			
			for prmdisp in ParamDispatchers.values():
				# Refresh New Download panel's widgets.
				prmdisp.cond_update_params_dict(params, optnam, optval)
			
		if params.has_key('--directory-prefix'):
			prepend_uniq(LastFolders, params['--directory-prefix'])
		
		old_urls = p1t1.get_text()
		new_urls = '\n'.join(cliURLs) + '\n'
		if win_newdl.props.visible and append_url:
			new_urls = old_urls + ('' if len(old_urls)==0 or old_urls[-1] == '\n' else '\n') + new_urls
		# TODO ha mar nyitva volt a panel akkor csak azt allitsa be ami nincs vagy amit a user nem irt felul
		p1t1.set_text(new_urls)
		show_win_newdl()

def act_quit():
	if any(dl.running for it, dl in iter_downloadlist()) and not question(_("Running downloads will continue in the background.\nQuit anyway?"), yes=gtk.STOCK_QUIT, default=gtk.RESPONSE_NO):
		return True
	gtk.main_quit()
	export_downloads()
	return False

def import_downloads():
	for f in os.listdir(CacheFolder):
		if re.match('^gwget-\d+\.obj$', f):
			f = os.path.join(CacheFolder, f)
			fh = open(f, 'r')
			obj = pickle.load(fh)
			fh.close()
			obj.resurgo()
			DownLoadList_append_new({COL_DLOBJ: obj})
	refresh_download_state_all()

def export_downloads():
	for it, dl in iter_downloadlist():
		dl.morior()
		fh = open(dl.get_dumpfile(), 'w')
		pickle.dump(dl, fh)
		fh.close()

def next_logfile():
	num = 1
	while True:
		num = next_file_number(glob.escape(os.path.join(CacheFolder, 'gwget-')), '.log', num)
		fpath = os.path.join(CacheFolder, 'gwget-%d.log' % (num))
		if all(fpath != dl.logfile for it, dl in iter_downloadlist()):
			break
		num += 1
	return fpath

class iter_downloadlist(object):
	def __init__(self):
		self.model = DownLoadList
		self.cur_iter = self.model.get_iter_first()
	def __iter__(self):
		return self
	def next(self):
		if self.cur_iter is None:
			raise StopIteration
		ret= (self.cur_iter, self.model[self.cur_iter][COL_DLOBJ])
		self.cur_iter = self.model.iter_next(self.cur_iter)
		return ret
	def __del__(self):
		pass

def called_by_self():
	# Prevent Deadlock
	stack = traceback.extract_stack()
	selfname = stack[-2][2]
	return any(c[2] == selfname for c in stack[:-2])

def refresh_download_state_all():
	return refresh_download_state(None)

def refresh_download_state(dlobj):
	if called_by_self():
		return
	if threading.currentThread().name != 'MainThread':
		gtk.threads_enter()
	doAll = dlobj is None
	for it, dl in iter_downloadlist():
		row = DownLoadList[it]
		if doAll or dlobj == dl:
			if not(main_list.get_data('refresh-lock') and main_list.get_data('editing-row').path == DownLoadList[it].path):
				if dl.outfile is None:
					row[COL_NAME] = os.path.basename(re.sub('/+$', '', urlparse.urlparse(dl.get_url() or 'data').path))
				else:
					row[COL_NAME] = os.path.basename(dl.outfile)
					if os.path.exists(dl.outfile):
						row[COL_NAMEEDITABLE] = 1
				
				mime = dl.mime_local
				if not mime:
					if dl.completed:
						dl.set_mime_local()
						mime = dl.mime_local
					if not dl.completed or mime is None:
						mime = dl.mime_remote
				icon = gio.content_type_get_icon(mime or MIME_DEFAULT)
				theme = gtk.icon_theme_get_default()
				info = theme.choose_icon(icon.get_names(), gtk.ICON_SIZE_MENU, 0)
				if info is not None:
					row[COL_FILE_ICON] = None
					row[COL_PXB] = info.load_icon()
				else:
					row[COL_PXB] = None
					row[COL_FILE_ICON] = gtk.STOCK_FILE
				
				if dl.percent >= 0:
					row[COL_PULSE] = -1
					row[COL_PERCENT] = dl.percent
					row[COL_PRCSTR] = str(dl.percent) + '%'
				else:
					row[COL_PERCENT] = 0
					if dl.running and not dl.completed:
						if row[COL_PULSE] < 0:
							row[COL_PULSE] = 0
						try: row[COL_PULSE] += 1
						except TypeError: row[COL_PULSE] = 1
					else:
						if dl.completed:
							row[COL_PERCENT] = 100
							row[COL_PULSE] = gobject.constants.G_MAXINT
						else:
							row[COL_PULSE] = 0
					row[COL_PRCSTR] = ''
				row[COL_STATUS_ICON] = StatusIcon[dl['status']]
				row[COL_STATUS] = _(Status[dl['status']])
				row[COL_MESSAGE] = '<tt>' + glib.markup_escape_text(dl.lastline) + '</tt>'
				
				row[COL_SPEED_BPS] = dl.speed
				row[COL_SPEED_STR] = dl.speed_str
				row[COL_ETA_SEC] = dl.eta
				row[COL_ETA_STR] = dl.eta_str
				row[COL_ADDED_TSTMP] = dl.added_ts
				row[COL_ADDED_DATE] = str_accurate_at_time(dl.added_ts)
			
			# if the current download is selected, then refresh toolbuttons sensitivity
			if main_selection.iter_is_selected(it):
				on_selection_change(main_selection)
			if not doAll:
				break
	if threading.currentThread().name != 'MainThread':
		gtk.threads_leave()

def pulse_download(pid):
	for it, dl in iter_downloadlist():
		try:
			if dl['pid'] == pid:
				DownLoadList[it][COL_PULSE] += 1
				break
		except KeyError:
			pass

def continous_refresh(wait):
	while True:
		refresh_download_state_all()
		time.sleep(wait)

def start_next_download(prev_dl):
	assert(prev_dl.get_url())
	this_host = urlparse.urlparse(prev_dl.get_url()).hostname
	start_dl = None
	for it, dl in sorted(iter_downloadlist(), key = lambda(it, dl): dl.added_ts):
		if not dl.get_url(): continue
		if dl.params['runnable'] and this_host == urlparse.urlparse(dl.get_url()).hostname:
			# this is a DL on the same host as the finished one was on
			if dl['status'] in [S_INIT, S_DL]:
				# if there is at least one DL initializing or downloading, then stop lookup
				start_dl = None
				break
			if start_dl is None and dl['status'] in [S_QUEUE]:
				# this is a queued DL, start it unless an other DL matched above
				start_dl = dl
	if start_dl is not None:
		start_dl.start()

def setxattributes(dl):
	attrs = {XATTR_URI: dl.original_url}
	if dl.mime_remote not in [None, MIME_DEFAULT]:
		attrs[XATTR_MIME] = dl.mime_remote
	if dl.params.has_key('--referer'):
		attrs[XATTR_REFERER] = dl.params['--referer']
	set_xattrs_file(dl.outfile, attrs)

def on_completed_download(dl):
	if os.path.exists(dl.outfile):
		setxattributes(dl)
		if not (hasattr(dl, 'manually_renamed') and dl.manually_renamed):
			rename_to_filepath = None
			warnfail = False
			if dl.params.has_key('rename_to'):
				# User requested renaming
				if os.path.isabs(dl.params['rename_to']):
					rename_to_filepath = dl.params['rename_to']
				else:
					rename_to_filepath = os.path.join(dl.params['--directory-prefix'], dl.params['rename_to'])
				mkdir(os.path.dirname(rename_to_filepath))
				warnfail = True
			elif isinstance(dl, DataDownload):
				# Data scheme, guess extension from content
				if dl.mime_local:
					path, extold = os.path.splitext(dl.outfile)
					extnew = guess_extension(dl.mime_local)
					if extnew and extnew != extold:
						rename_to_filepath = path + extnew
			elif re.match('.*\?[^?]+=', dl.outfile):
				# Otherwise strip URL query string from filename
				rename_to_filepath = re.sub('\?[^?]+=[^?]*', '', dl.outfile)
			if rename_to_filepath is not None:
				if rename_downloaded_file(dl, rename_to_filepath, warnfail=warnfail):
					setxattributes(dl)
				refresh_download_state(dl)
	if dl.params.has_key('on_complete'):
		s = dl.params['on_complete']
		SQ = '\''
		esc_filename = SQ + dl.outfile.replace(SQ, SQ+'\\'+SQ+SQ) + SQ
		shcmd = s.replace('{}', esc_filename)
		run_detached('sh', ['-c', shcmd])

def rename_downloaded_file(dl, newpath, warnfail=True):
	if dl.outfile == newpath:
		return None
	if os.path.exists(newpath):
		display_error(_("Target already exists, not renaming.\nFile: <tt>%s</tt>\nTarget: <tt>%s</tt>") % (glib.markup_escape_text(dl.outfile), glib.markup_escape_text(newpath)), isPango=True, gtkErrorLevel=gtk.MESSAGE_WARNING)
	else:
		try:
			try:
				os.rename(dl.outfile, newpath)
			except OSError as e:
				if e.errno == os.errno.EXDEV:
					if dl.completed:
						cmd = run_synchronous('mv', ['--no-clobber', dl.outfile, newpath])
						if cmd.exitcode != 0:
							e = ShellCommandException()
							e.message = re.sub('\n*$', '', cmd.stderr)
							e.errno = cmd.exitcode
							raise e
					else:
						if e.message: e.message += '\n'
						e.message += _("Refused moving an incompleted file across filesystems.")
						raise e
				else:
					raise e
		except (OSError, ShellCommandException) as e:
			e.filename = None
			e.filenames = [dl.outfile, newpath]
			display_error(e)
		else:
			dl.outfile = newpath
			return True
	return False

def DownLoadList_append_new(d):
	# COL_DLOBJ, COL_NAME, COL_FILE_ICON, COL_PXB, COL_ADDED_TSTMP, COL_ADDED_DATE, 
	#   COL_PRCSTR, COL_PERCENT, COL_PULSE, COL_SPEED_BPS, COL_SPEED_STR, 
	#   COL_ETA_SEC, COL_ETA_STR, COL_STATUS_ICON, COL_STATUS, COL_MESSAGE, COL_NAMEEDITABLE
	# DownLoadList = gtk.ListStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, int, str, 
	#   str, float, int, float, str, 
	#   int, str, str, str, str, bool)
	# it = DownLoadList.append([dl, os.path.basename(url), gtk.STOCK_FILE, None, int(time.time()), str_accurate_at_time(time.time()), 
	#   '', 0, 0, -1, '', 
	#   -1, '', gtk.STOCK_MEDIA_STOP, _(Status[S_QUEUE]), '', False])
	row = [None, '', '', None, 0, '',  '', 0, 0, -1, '',  -1, '', '', '', '', False]
	for idx, val in d.iteritems():
		row[idx] = val
	return DownLoadList.append(row)

def start_new_download(url, params, start=True):
	urlparts = urlparse.urlparse(url)
	if urlparts.scheme == 'data':
		dl = DataDownload(url, params)
		start = True
	else:
		dl = Download(url, params)
	it = DownLoadList_append_new({COL_DLOBJ: dl})
	refresh_download_state(dl)
	if start:
		dl.start()
	return it

def reset_parameters(params={}):
	for opt, prmdisp in ParamDispatchers.iteritems():
		if params.has_key(opt):
			# Fill widgets with given wget parameters.
			prmdisp.set_value(params[opt], reset=True)
		else:
			# Reset widget to empty/default values.
			prmdisp.set_value(None, reset=True)

def show_win_newdl():
	win_newdl.show()
	for n in reversed(range(0, note.get_n_pages())):
		note.set_current_page(n)
	p1t1.grab_focus()
	p1c1.set_history(LastFolders)



### Interface procedures ###

def act_new():
	show_win_newdl()
	reset_parameters()

def act_start_all():
	for it, dl in iter_downloadlist():
		if not dl.running and not dl.completed:
			act_start(None, dl)

def act_pause_all():
	for it, dl in iter_downloadlist():
		if dl.running:
			act_pause(None, dl)
		elif dl['status'] == S_QUEUE:
			dl.params['runnable'] = False

def act_clear_completed():
	for it, dl in iter_downloadlist():
		if dl.completed:
			act_clear_download(it, dl)

def act_options():
	pass


def act_open_file(it, dl):
	if dl.outfile is not None:
		run_detached('mimeopen-gui', [dl.outfile])

def act_open_folder(it, dl):
	run_detached('mimeopen-gui', [os.path.dirname(dl.outfile)])

def act_open_referer(it, dl):
	run_detached('mimeopen-gui', [dl.params['--referer']])

def act_open_clipboard(it, dl):
	Clipboard.set_text(dl.outfile)

def act_start(it, dl):
	dl.start()

def act_refetch(it, dl):
	if dl.outfile is not None:
		delete(dl.outfile)
	dl.start()

def act_pause(it, dl):
	dl.stop()

def act_remove_download(it, dl, force=False):
	if not dl.running and dl.outfile is not None:
		if not dl.completed or force or question(_("Do you want to <b>delete completed</b> file?\nURL: <tt>%s</tt>\nFile: <tt>%s</tt>") % (glib.markup_escape_text(dl.original_url or '') or MDASH_UTF8, glib.markup_escape_text(dl.outfile or '') or MDASH_UTF8), yes=gtk.STOCK_DELETE, default=gtk.RESPONSE_NO):
			delete(dl.outfile)

def act_clear_download(it, dl):
	if not dl.running:
		if not dl.completed and dl.outfile is not None and os.path.exists(dl.outfile):
			try:
				if question(_("This download is not completed.\nDo you want to <b>delete partial</b> file?\nURL: <tt>%s</tt>\nFile: <tt>%s</tt>") % (glib.markup_escape_text(dl.original_url or '') or MDASH_UTF8, glib.markup_escape_text(dl.outfile or '') or MDASH_UTF8), yes=gtk.STOCK_DELETE, no=(_("Clear"), gtk.STOCK_CLEAR), cancelable=True, default=gtk.RESPONSE_CANCEL):
					act_remove_download(it, dl, force=True)
			except DialogCancel:
				return
		if dl.logfile is not None:
			untrack_download_file(dl)
		del DownLoadList[it]

def untrack_download_file(dl):
	delete(dl.get_dumpfile())
	delete(dl.logfile)

def act_show_log(it, dl):
	def add_context_menuitems(txv, menu, scrtxv):
		menu.prepend(gtk.SeparatorMenuItem())
		mi = StockMenuItem(None, gtk.STOCK_REFRESH)
		mi.connect('activate', lambda mi, *userparams: simple_load_file_into_scrolledtextview(*userparams), dl.logfile, scrtxv)
		menu.prepend(mi)
		menu.show_all()
	
	win_log = gtk.Window()
	scrtxv = ScrolledTextView()
	win_log.set_default_size(675, 345)
	win_log.set_title(_("Log - %s") % (os.path.basename(dl.logfile)))
	win_log.set_icon_name('emblem-downloads')
	win_log.connect('delete-event', lambda w,e: w.destroy())
	add_key_binding(win_log, 'Escape', lambda a,b,c,d: win_log.destroy() or True)
	win_log.set_transient_for(win_main)
	win_log.set_modal(True)
	win_log.add(scrtxv)
	scrtxv.set_editable(False)
	scrtxv.get_textview().connect('populate-popup', add_context_menuitems, scrtxv)
	win_log.show_all()
	simple_load_file_into_scrolledtextview(dl.logfile, scrtxv)

def simple_load_file_into_scrolledtextview(filepath, textview):
	try:
		fh = open(filepath, 'r')
		textview.set_text(''.join(fh.readlines()))
		fh.close()
	except IOError as e:
		display_error(e)

def act_props(it, dl):
	#print dl.__dict__
	show_win_newdl()
	reset_parameters(dl.params)
	p1t1.set_text(dl.original_url or '')



def act_on_selection(func, maxi=None):
	iters = []
	for itpath in main_selection.get_selected_rows()[1]:
		iters.append(DownLoadList.get_iter(itpath))
	if maxi is None or len(iters) <= maxi:
		for it in iters:
			func(it, DownLoadList[it][COL_DLOBJ])

def on_selection_change(selection):
	iters = map(lambda p: DownLoadList.get_iter(p), selection.get_selected_rows()[1])
	dls = map(lambda it: DownLoadList[it][COL_DLOBJ], iters)
	num = len(iters)
	btn_resume.set_sensitive(num>0 and all(not dl.running and not(dl.completed and os.path.exists(dl.outfile)) for dl in dls))
	btn_pause.set_sensitive(num>0 and all(dl.running for dl in dls))
	btn_remove.set_sensitive(num>0 and all(dl.outfile is not None and not dl.running for dl in dls))
	btn_clear.set_sensitive(num>0 and all(not dl.running for dl in dls))
	btn_props.set_sensitive(num == 1)

def on_context_menu(menuitem, function):
	it = ContextMenu.get_data('iterator')
	dl = DownLoadList[it][COL_DLOBJ]
	function(it, dl)
	return True

def event_masked(event):
	return any(event.state & getattr(gtk.gdk, mask+'_MASK') for mask in ['CONTROL','SHIFT','MOD4','MOD5','META'])

def popup_context_menu(it, event, button=None, placement_func=None):
	dl = DownLoadList[it][COL_DLOBJ]
	ContextMenu.set_data('iterator', it)
	cmi_open_file.set_sensitive(dl.outfile is not None)
	cmi_open_referer.set_sensitive(dl.params.has_key('--referer'))
	cmi_remove.set_sensitive(dl.outfile is not None and not dl.running and os.path.exists(dl.outfile))
	cmi_refetch.set_sensitive(not dl.running)
	cmi_resume.set_sensitive(not dl.running and not(dl.completed and os.path.exists(dl.outfile)))
	cmi_pause.set_sensitive(dl.running)
	cmi_clear.set_sensitive(not dl.running)
	if button is None: button = event.button
	ContextMenu.popup(None, None, placement_func, button, event.time)

def on_urls_edited(buf):
	if len(p1t1.get_text().split()) > 1:
		p1e1.hide()
	else:
		p1e1.show()

def on_treeview_click(tree, event):
	if event_masked(event):
		return False
	itpathinfo = main_list.get_path_at_pos(int(event.x), int(event.y))
	if itpathinfo is not None:
		itpath, col, cellx, celly = itpathinfo
		it = DownLoadList.get_iter(itpath)
		dl = DownLoadList[it][COL_DLOBJ]
		if event.type == gtk.gdk.BUTTON_PRESS and event.button == 3:
			main_selection.unselect_all()
			main_selection.select_iter(it)
			popup_context_menu(it, event)
			return True
		elif event.type == gtk.gdk._2BUTTON_PRESS and event.button == 1:
			act_open_file(it, dl)
			return True
	return False

def on_treeview_key(tree, event):
	if event_masked(event):
		return False
	if event.keyval == gtk.gdk.keyval_from_name('Delete'):
		act_on_selection(act_clear_download)
		return True
	rows = main_selection.get_selected_rows()[1]
	if len(rows) == 1:
		it = DownLoadList.get_iter(rows[0])
	if event.keyval == gtk.gdk.keyval_from_name('Menu'):
		if len(rows) == 1:
			x, y = tree.window.get_origin()
			popup_context_menu(it, event, 3, placement_func = lambda d: (x, y, True))
			return True
	if event.keyval in map(gtk.gdk.keyval_from_name, ['Return', 'KP_Enter']):
		if len(rows) == 1:
			dl = DownLoadList[it][COL_DLOBJ]
			act_open_file(it, dl)
		return True
	return False


## New Download window

# Start new download(s)
def new_download(start=True, doOpen=False):
	selected_folder = ParamDispatchers['--directory-prefix'].get_value()
	prepend_uniq(LastFolders, selected_folder)
	
	# Read widgets and build up wget parameters.
	params = {}
	for prmdisp in ParamDispatchers.values():
		prmdisp.update_params_dict(params)
	if doOpen:
		params['on_complete'] = 'mimeopen-gui {}'
	params['runnable'] = start
	
	main_selection.unselect_all()
	uniq_url = {}
	uniq_host = {}
	for url in p1t1.get_text().split():
		if not uniq_url.has_key(url):
			this_hostname = urlparse.urlparse(url).hostname
			if start:
				start_this = all(this_hostname != host for host in uniq_host.iterkeys())
			else:
				start_this = False
			it = start_new_download(url, params, start=start_this)
			main_selection.select_iter(it)
			uniq_url[url] = 1
			uniq_host[this_hostname] = 1
	win_newdl.hide()

def DnD_motion(wdg, context, x, y, time):
	action = None
	for act in gtk.gdk.ACTION_COPY, gtk.gdk.ACTION_MOVE:
		if context.suggested_action & act:
			action = act
			break
	if 'text/plain' in context.targets and action is not None:
		wdg.drag_highlight()
		context.drag_status(action, time)
		return True
	return False

def DnD_accept(wdg, context, x, y, time):
	accepted = False
	typ = 'text/plain'
	if typ in context.targets:
		wdg.drag_get_data(context, typ, time)
		accepted = True
	context.drop_reply(accepted, time)
	wdg.drag_unhighlight()
	return True

def DnD_receive(wdg, context, x, y, selectiondata, info, time):
	success = False
	if selectiondata.get_length() > -1:
		typ = selectiondata.get_data_type()
		if typ == 'text/plain':
			urls = '\n'.join(selectiondata.get_text().split())+'\n'
			act_new()
			p1t1.set_text(urls)
			if context.action == gtk.gdk.ACTION_MOVE:
				new_download()
			success = True
	context.finish(success, False, time)
	return True

class GwgetService(dbus.service.Object):
	def __init__(self, win_main):
		self.win = win_main
		bus_name = dbus.service.BusName(APPNAME, bus = dbus.SessionBus())
		dbus.service.Object.__init__(self, bus_name, '/'+APPNAME.replace('.', '/'))
	@dbus.service.method(dbus_interface = APPNAME)
	def new_download(self, args, cwd):
		gtk.threads_enter()
		if len(args) < 2:
			self.win.present()
		main_parse_cli(args, append_url=True, cwd=cwd)
		gtk.threads_leave()

class ParamDispatcher(object):
	def __init__(self, widget, optname):
		self.widget = widget
		self.optname = optname
		self.negative_optname = self.negate_optname(optname)
		self.ext_getter = None
		self.ext_setter = None
	@staticmethod
	def negate_optname(optname):
		if optname.startswith('--no-'):
			return '--' + optname[5:]
		else:
			return '--no-' + optname[2:]
	@staticmethod
	def convert_to_wget_args(params):
		wget_args_all = []
		for k, v in params.iteritems():
			if k.startswith('-'):
				if type(v) == list:
					for v1 in v:
						wget_args_all.append(k)
						wget_args_all.append(v1)
				elif v != '':
					if k.startswith('--') and v is False:
						k = '--no-' + k[2:]
					wget_args_all.append(k)
					if v not in [True, False, None]:
						wget_args_all.append(v)
			elif k == '':
				# append custom options
				for v1 in v:
					wget_args_all.append(v1)
		return wget_args_all
	@staticmethod
	def update_unknown_param(params, option, optval=None):
		if not params.has_key(''):
			params[''] = []
		if optval is False:
			params[''] += ['--no-' + option[2:]]
		else:
			params[''] += [option]
			if optval not in [None, True]:
				params[''] += [optval]
	def cond_update_params_dict(self, params, optnam, optval):
		if self.optname == '' and not ParamDispatchers.has_key(optnam) and not ParamDispatchers.has_key(self.negate_optname(optnam)):
			self.update_unknown_param(params, optnam, optval)
			return
		if optnam not in [self.optname, self.negative_optname]:
			return False
		first_set_value = self.widget.get_data('first-setup')
		if first_set_value:
			# Do not overwrite if has been set.
			return
		else:
			current_raw_val = self.get_raw_value()
			if first_set_value is None:
				default_val = self.widget.get_data('default-value')
				if default_val is not None and current_raw_val != default_val:
					# Do not overwrite if edited by user.
					return
			elif first_set_value == '':
				# Do not overwrite if edited by user.
				if current_raw_val != '':
					return
		
		if self.optname in ParameterlessOptions and optval is None:
			optval = (optnam == self.optname)
		self.set_value(optval)
		self.update_params_dict(params)
	def update_params_dict(self, params):
		val = self.get_value()
		if val is None:
			if params.has_key(self.optname):
				del params[self.optname]
		else:
			typ = type(val)
			if typ == bool:
				if val and params.has_key(self.negative_optname):
					del params[self.negative_optname]
				elif not val and params.has_key(self.optname):
					del params[self.optname]
			if typ in [float, int]:
				params[self.optname] = str(int(val))
			elif typ == list:
				# Returning type is list, append to the list of values.
				if not params.has_key(self.optname):
					params[self.optname] = []
				if type(params[self.optname]) != list:
					params[self.optname] = [params[self.optname]]
				params[self.optname] += val
			# Disallow empty option parameters.
			elif val != '':
				params[self.optname] = val
	def get_raw_value(self):
		if isinstance(self.widget, gtk.CheckButton):
			val = self.widget.get_active()
		elif isinstance(self.widget, gtk.SpinButton):
			val = self.widget.get_value()
		else:
			val = self.widget.get_text()
		return val
	def get_value(self):
		# Get value by method proper to widget type
		val = self.get_raw_value()
		if self.ext_getter is False:
			val = None
		elif self.ext_getter is not None:
			# Filter value by extender function
			sgn = inspect.getargspec(self.ext_getter)
			if len(sgn.args) < 2 and sgn.varargs is None:
				val = self.ext_getter(val)
			else:
				val = self.ext_getter(val, self.widget)
		return val
	def set_getter(self, fnc):
		self.ext_getter = fnc
	def put_wget_args(self, args):
		pass
	def set_value(self, val, reset=False):
		self.widget.set_data('first-setup', val)
		if val is None:
			val = self.widget.get_data('default-value')
		else:
			if self.ext_setter:
				sgn = inspect.getargspec(self.ext_setter)
				if len(sgn.args) < 2 and sgn.varargs is None:
					val = self.ext_setter(val)
				else:
					val = self.ext_setter(val, self.widget)
		
		if isinstance(self.widget, gtk.CheckButton):
			self.widget.set_active(bool(val))
		elif isinstance(self.widget, gtk.SpinButton):
			if val is None: val = 0
			self.widget.set_value(int(val))
		else:
			if val is None: val = ''
			self.widget.set_text(str(val))
	def set_putter(self, fnc):
		self.ext_setter = fnc
	def __repr__(self):
		return '<ParamDispatcher %s=%s>' % (self.optname, repr(self.get_value()),)



### Main ###

setproctitle.setproctitle(PROGNAME)
gettext.textdomain(PROGNAME)
_ = gettext.gettext
LastFolder = os.getcwd()
LastFolders = [LastFolder]
XATTR_URI = 'user.xdg.origin.url'
XATTR_REFERER = 'user.xdg.referrer.url'
XATTR_MIME = 'user.mime_type'
XATTR_CHARSET = 'user.charset'
MDASH_UTF8 = '—'
MIME_DEFAULT = 'application/octet-stream'
CacheFolder = os.path.join(os.environ['HOME'], '.cache', 'gwget')
COL_DLOBJ, COL_NAME, COL_FILE_ICON, COL_PXB, COL_ADDED_TSTMP, COL_ADDED_DATE, COL_PRCSTR, COL_PERCENT, COL_PULSE, COL_SPEED_BPS, COL_SPEED_STR, COL_ETA_SEC, COL_ETA_STR, COL_STATUS_ICON, COL_STATUS, COL_MESSAGE, COL_NAMEEDITABLE = range(17)
DownLoadList = gtk.ListStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, float, str, str, float, int, float, str, int, str, str, str, str, bool)
S_QUEUE, S_INIT, S_DL, S_SAVED, S_ERR, S_STOP, S_GUILOCK = range(7)
Status = {
	S_QUEUE: "Queued",
	S_INIT: "Init",
	S_DL: "Download",
	S_SAVED: "Saved",
	S_ERR: "Failed",
	S_STOP: "Paused",
	S_GUILOCK: "Editing",
}
StatusIcon = {
	S_QUEUE: gtk.STOCK_MEDIA_STOP,
	S_INIT: 'media-seek-forward',
	S_DL: 'media-playback-start',
	S_SAVED: gtk.STOCK_APPLY,
	S_ERR: gtk.STOCK_NO,
	S_STOP: gtk.STOCK_MEDIA_PAUSE,
	S_GUILOCK: gtk.STOCK_EDIT,
}
# gwget cli options not requiring parameter
ParameterlessOptions = ['--cwd-prefix', '--content-disposition']
OSMaxFiles = resource.getrlimit(resource.RLIMIT_NOFILE)[0]


# Check if application is already running
if dbus.SessionBus().request_name(APPNAME) != dbus.bus.REQUEST_NAME_REPLY_PRIMARY_OWNER:
	stderr(PROGNAME+': '+_("Already running.")+'\n')
	method = dbus.SessionBus().get_object(APPNAME, '/'+APPNAME.replace('.', '/')).get_dbus_method('new_download')
	method(sys.argv, os.getcwd())
	raise SystemExit(0)


gtk.gdk.threads_init()
mkdir(CacheFolder)
Clipboard = gtk.Clipboard(selection='CLIPBOARD')


### Build GUI ###

## Main window

# Declare main window's widgets
win_main = gtk.Window()
box_main = gtk.VBox()
main_toolbar = gtk.Toolbar()
scroller = gtk.ScrolledWindow()
main_list = gtk.TreeView(DownLoadList)
main_selection = main_list.get_selection()
ContextMenu = gtk.Menu()
ContextMenuOpen = gtk.Menu()
cmi_open = StockMenuItem(None, gtk.STOCK_OPEN)
cmi_open_file = StockMenuItem(None, gtk.STOCK_OPEN)
cmi_open_folder = StockMenuItem(_("Open Folder"), gtk.STOCK_DIRECTORY)
cmi_open_referer = StockMenuItem(_("Open Website"), 'applications-internet')
cmi_open_clipboard = StockMenuItem(_("Copy path"), gtk.STOCK_COPY)
cmi_remove = StockMenuItem(_("Delete File"), gtk.STOCK_DELETE)
cmi_refetch = StockMenuItem(_("Re-download"), gtk.STOCK_REFRESH)
cmi_resume = StockMenuItem(_("Resume"), gtk.STOCK_MEDIA_PLAY)
cmi_pause = StockMenuItem(_("Pause"), gtk.STOCK_MEDIA_PAUSE)
cmi_clear = StockMenuItem(_("Clear"), gtk.STOCK_CLEAR)
cmi_log = StockMenuItem(_("Show Log"), gtk.STOCK_INFO)
cmi_props = StockMenuItem(None, gtk.STOCK_PROPERTIES)


# Configure main window's widgets
win_main.set_default_size(950, 450)
win_main.set_title(_("Downloads"))
win_main.set_icon_name('emblem-downloads')
start_evt = win_main.connect('map-event', lambda w,e: (win_main.disconnect(start_evt), win_main_show()))
win_main.connect('delete-event', lambda w,e: act_quit())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_new())
add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_start_all())
add_key_binding(win_main, '<Control>k', lambda a,b,c,d: act_pause_all())
add_key_binding(win_main, '<Control>l', lambda a,b,c,d: act_on_selection(act_show_log, 1))
add_key_binding(win_main, '<Control>p', lambda a,b,c,d: act_on_selection(act_props, 1))
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_options())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())

toolbuttons = [
	(None, gtk.STOCK_NEW, None, act_new),
	(_("Resume All"), gtk.STOCK_MEDIA_PLAY, None, act_start_all),
	(_("Pause All"), gtk.STOCK_MEDIA_PAUSE, None, act_pause_all),
	(_("Clear Completed"), gtk.STOCK_CLEAR, None, act_clear_completed),
	(None, None, None, 'separator'),
	(_("Resume"), gtk.STOCK_MEDIA_PLAY, None, (act_on_selection, act_start)),
	(_("Pause"), gtk.STOCK_MEDIA_PAUSE, None, (act_on_selection, act_pause)),
	(_("Delete File"), gtk.STOCK_DELETE, None, (act_on_selection, act_remove_download)),
	(_("Clear"), gtk.STOCK_CLEAR, None, (act_on_selection, act_clear_download)),
	(None, gtk.STOCK_PROPERTIES, None, (act_on_selection, act_props)),
	(None, None, None, 'space'),
	(None, gtk.STOCK_PREFERENCES, None, act_options),
	(None, gtk.STOCK_QUIT, None, act_quit),
]
x, x, x, x, x_, btn_resume, btn_pause, btn_remove, btn_clear, btn_props, x_, x, x \
= load_toolitems(main_toolbar, toolbuttons)
on_selection_change(main_selection)


tvc0 = gtk.TreeViewColumn(_("Filename"))
tvc0.set_resizable(True)
tvc0.set_sort_column_id(COL_NAME)
tvc0.set_sort_indicator(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
cr_txt.connect('editing-started', treeview_column0_editing)
cr_txt.connect('editing-canceled', treeview_column0_edit_canceled)
cr_txt.connect('edited', treeview_column0_edited)
tvc0.pack_start(cr_pix, False)
tvc0.pack_start(cr_txt, True)
tvc0.add_attribute(cr_txt, 'text', COL_NAME)
tvc0.add_attribute(cr_txt, 'editable', COL_NAMEEDITABLE)
tvc0.add_attribute(cr_pix, 'icon-name', COL_FILE_ICON)
tvc0.add_attribute(cr_pix, 'pixbuf', COL_PXB)
main_list.append_column(tvc0)
tvc = gtk.TreeViewColumn(_("Progress"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_PERCENT)
tvc.set_sort_indicator(True)
cr_prc = gtk.CellRendererProgress()
tvc.pack_start(cr_prc, True)
tvc.add_attribute(cr_prc, 'text', COL_PRCSTR)
tvc.add_attribute(cr_prc, 'value', COL_PERCENT)
tvc.add_attribute(cr_prc, 'pulse', COL_PULSE)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Status"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_STATUS)
tvc.set_sort_indicator(True)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_STATUS)
tvc.add_attribute(cr_pix, 'icon-name', COL_STATUS_ICON)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Speed"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_SPEED_BPS)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_SPEED_STR)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Added"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_ADDED_TSTMP)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_ADDED_DATE)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("ETA"))
tvc.set_resizable(True)
tvc.set_sort_column_id(COL_ETA_SEC)
tvc.set_sort_indicator(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_ETA_STR)
main_list.append_column(tvc)
tvc = gtk.TreeViewColumn(_("Message"))
tvc.set_sort_column_id(COL_MESSAGE)
tvc.set_sort_indicator(True)
tvc.set_resizable(True)
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'markup', COL_MESSAGE)
main_list.append_column(tvc)

DownLoadList.set_sort_column_id(COL_ADDED_TSTMP, gtk.SORT_DESCENDING)
main_list.set_rules_hint(True)
main_list.set_reorderable(True)
main_list.set_enable_search(True)
main_list.set_search_column(COL_NAME)
#main_list.set_search_position_func() #TODO
main_list.connect('button-press-event', on_treeview_click)
main_list.connect('key-press-event', on_treeview_key)
main_list.drag_dest_set(0, [], 0)
main_list.connect('drag-motion', DnD_motion)
main_list.connect('drag-drop', DnD_accept)
main_list.connect('drag-data-received', DnD_receive)
main_selection.set_mode(gtk.SELECTION_MULTIPLE)
main_selection.connect('changed', on_selection_change)
cmi_open_file.connect('activate', on_context_menu, act_open_file)
cmi_open_folder.connect('activate', on_context_menu, act_open_folder)
cmi_open_referer.connect('activate', on_context_menu, act_open_referer)
cmi_open_clipboard.connect('activate', on_context_menu, act_open_clipboard)
cmi_remove.connect('activate', on_context_menu, act_remove_download)
cmi_refetch.connect('activate', on_context_menu, act_refetch)
cmi_resume.connect('activate', on_context_menu, act_start)
cmi_pause.connect('activate', on_context_menu, act_pause)
cmi_clear.connect('activate', on_context_menu, act_clear_download)
cmi_log.connect('activate', on_context_menu, act_show_log)
cmi_props.connect('activate', on_context_menu, act_props)


# Pack main window's widgets
win_main.add(box_main)
box_main.pack_start(main_toolbar, 0, 1)
box_main.pack_start(scroller, 1, 1)
scroller.add_with_viewport(main_list)
scroller.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
ContextMenu.append(cmi_open)
cmi_open.set_submenu(ContextMenuOpen)
ContextMenuOpen.append(cmi_open_file)
ContextMenuOpen.append(cmi_open_folder)
ContextMenuOpen.append(cmi_open_referer)
ContextMenuOpen.append(cmi_open_clipboard)
ContextMenu.append(cmi_remove)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_refetch)
ContextMenu.append(cmi_resume)
ContextMenu.append(cmi_pause)
ContextMenu.append(cmi_clear)
ContextMenu.append(gtk.SeparatorMenuItem())
ContextMenu.append(cmi_log)
ContextMenu.append(cmi_props)
ContextMenu.show_all()


## New Download window

# Declare new download window's widgets
win_newdl = gtk.Window()
box_newdl = gtk.VBox()
note = gtk.Notebook()
page1 = gtk.VBox()
p1x1 = gtk.HBox()
p1l1 = gtk.Label(_("URLs"))
p1t1 = ScrolledTextView()
p1e1 = LabelledEntry(label=_("Rename to"), tooltip=_("Left empty to use filename provided by server/wget"))
p1c1 = FileChooserEntry(label=_("Target Folder"), path=LastFolder, action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
p1x2 = gtk.HBox(spacing=2)
p1l2a = gtk.Label(_("Bandwidth limit"))
p1a2 = gtk.Adjustment(value=0, lower=0, upper=gobject.constants.G_MAXINT, step_incr=1, page_incr=10)
p1s2 = gtk.SpinButton(p1a2)
p1l2b = gtk.Label()
page2 = gtk.VBox()
p2x1 = gtk.VBox()
p2c1 = FileChooserEntry(label=_("Cookie file"), action=gtk.FILE_CHOOSER_ACTION_OPEN)
p2l1 = gtk.Label(_("Custom Cookies per line in NAME=VALUE format:"))
p2t1 = ScrolledTextView()
page3 = gtk.VBox()
p3l1 = gtk.Label(_("POST parameters per line in NAME=VALUE format:\nURL encoding is not necessary"))
p3t1 = ScrolledTextView()
page4 = gtk.VBox()
p4x1 = gtk.HBox(spacing=2)
p4l1a = gtk.Label(_("Attempts"))
p4a1 = gtk.Adjustment(value=1, lower=0, upper=gobject.constants.G_MAXINT, step_incr=1, page_incr=10)
p4s1 = gtk.SpinButton(p4a1)
p4l1b = gtk.Label()
p4e2 = LabelledEntry(label=_("Username"))
p4e3 = LabelledEntry(label=_("Password"))
p4e4 = LabelledEntry(label=_("Proxy URL"))
p4e5 = LabelledEntry(label=_("Referer"))
p4e6 = LabelledEntry(label=_("User Agent"))
p4c1 = gtk.CheckButton(label=_("Content-Disposition filename"))
p4e7 = LabelledEntry(label=_("Custom options"), tooltip=_("type further options for wget\nsee 'wget --help' or 'man wget'"))
p4e8 = LabelledEntry(label=_("Run on complete"), tooltip=_("type a shell command-line\npair of curly brackets are substituted with downloaded file name\nexample: xdg-open {} && rm {}"))
btns_newdl = gtk.HBox(spacing=5)
btn_new_save = StockButton(label=_("Download"), stock=gtk.STOCK_SAVE, tooltip='Ctrl-Enter')
btn_new_open = StockButton(stock=gtk.STOCK_OPEN)
btn_new_queue = StockButton(label=_("Queue"), stock=gtk.STOCK_ADD, tooltip='Ctrl-Shift-Enter')
btn_new_no = StockButton(stock=gtk.STOCK_CANCEL, tooltip='Esc')

# Configure new download window's widgets
win_newdl.set_transient_for(win_main)
win_newdl.set_modal(True)
win_newdl.set_title(_("New Download"))
win_newdl.set_icon_name('emblem-downloads')
win_newdl.connect('delete-event', lambda w,e: w.hide() or True)
add_key_binding(win_newdl, 'Escape', lambda a,b,c,d: win_newdl.hide() or True)
add_key_binding(win_newdl, '<Control>Return', lambda a,b,c,d: new_download() or True)
add_key_binding(win_newdl, '<Control><Shift>Return', lambda a,b,c,d: new_download(start=False) or True)
for spinner in p1s2, p4s1:
	spinner.set_numeric(True)
	spinner.set_alignment(1.0)
p1t1.get_buffer().connect('changed', on_urls_edited)
p1l2b.set_markup(_("kB/s <small><i>(0 = unlimited)</i></small>"))
p4l1b.set_markup(_("<small><i>(0 = infinite)</i></small>"))
p4e3.set_visibility(False)
p4c1.set_tooltip_text(_("wget parses Content-Disposition header for filename"))
btns_newdl.set_border_width(5)
btn_new_save.connect('clicked', lambda b: new_download())
btn_new_open.connect('clicked', lambda b: new_download(doOpen=True))
btn_new_queue.connect('clicked', lambda b: new_download(start=False))
btn_new_no.connect('clicked', lambda b: win_newdl.hide() or True)




ParamDispatcherExtends = {
	'--directory-prefix': (p1c1,\
		lambda a: a if a!='' else os.getcwd(),\
		None),
	'rename_to': (p1e1,\
		lambda a, w: a if w.get_visible() else None,\
		None),
	'--limit-rate': (p1s2,\
		lambda a: "%dk" % (a,),\
		lambda b: convert_to_bytes(b, 'k')),
	'--load-cookies': (p2c1, None, None),
	'--header': (p2t1,\
		# FIXME: non-Cookie headers
		lambda a: ['Cookie: ' + '; '.join(filter(lambda k: len(k), a.split('\n')))] if len(a.strip()) else None,\
		lambda b: '\n'.join(k.strip() for k in ';'.join(re.sub('^Cookie:\s+', '', h) for h in filter(lambda h: re.search('^Cookie: ', h), b)).split(';'))+'\n'),
	'--post-data': (p3t1,\
		lambda a: urllib.urlencode(dict(map(lambda p: (p if p.find('=')>-1 else p+'=').split('=', 1), filter(lambda p: len(p), a.split('\n'))))),\
		lambda b: '\n'.join(urllib.unquote(p) for p in b.split('&'))+'\n'),
	'--tries': (p4s1, None, None),
	'--user': (p4e2, None, None),
	'--password': (p4e3, None, None),
	'proxy': (p4e4, None, None),
	'--referer': (p4e5, None, None),
	'--user-agent': (p4e6, None, None),
	'--content-disposition': (p4c1, None, None),
	'': (p4e7,\
		lambda a: a.split(),\
		lambda b: ' '.join(b)),
	'on_complete': (p4e8, None, None),
}
# Map short wget options to long ones.
ShortLongOptions = {
	'-P': '--directory-prefix',
	'-t': '--tries',
	'-U': '--user-agent',
}
# Map gwget cli options to ParamDispatcher keys.
GWgetOptionsParam = {
	'--proxy-url': 'proxy',
	'--cookies': '--header',
	'--rename-to': 'rename_to',
	'--output-document': 'rename_to',
	'--run-on-complete': 'on_complete',
	'--cwd-prefix': '--directory-prefix',
}
for wdg, dflt in (p1s2, 0), (p4s1, 1), (p4c1, True):
	wdg.set_data('default-value', dflt)
ParamDispatchers = {}
for opt, (wdg, getter, putter) in ParamDispatcherExtends.iteritems():
	pd = ParamDispatcher(wdg, optname=opt)
	if getter: pd.set_getter(getter)
	if putter: pd.set_putter(putter)
	ParamDispatchers[opt] = pd


# Pack new download window's widgets
win_newdl.add(box_newdl)
box_newdl.pack_start(note, 1, 1)
note.append_page(page1, gtk.Label(_("Basic")))
page1.pack_start(p1x1, 1, 1)
p1x1.pack_start(p1l1, 0, 1)
p1x1.pack_start(p1t1, 1, 1)
page1.pack_start(p1e1, 0, 1)
page1.pack_start(p1c1, 0, 1)
page1.pack_start(p1x2, 0, 1)
p1x2.pack_start(p1l2a, 0, 1)
p1x2.pack_start(p1s2, 0, 1)
p1x2.pack_start(p1l2b, 0, 1)
note.append_page(page2, gtk.Label(_("Cookies")))
page2.pack_start(p2x1, 1, 1)
p2x1.pack_start(p2c1, 0, 1)
p2x1.pack_start(p2l1, 0, 1)
p2x1.pack_start(p2t1, 1, 1)
note.append_page(page3, gtk.Label(_("POST")))
page3.pack_start(p3l1, 0, 0)
page3.pack_start(p3t1, 1, 1)
note.append_page(page4, gtk.Label(_("Advanced")))
page4.pack_start(p4x1, 0, 1)
p4x1.pack_start(p4l1a, 0, 1)
p4x1.pack_start(p4s1, 0, 1)
p4x1.pack_start(p4l1b, 0, 1)
page4.pack_start(p4e2, 0, 1)
page4.pack_start(p4e3, 0, 1)
page4.pack_start(p4e4, 0, 1)
page4.pack_start(p4e5, 0, 1)
page4.pack_start(p4e6, 0, 1)
page4.pack_start(p4c1, 0, 1)
page4.pack_start(p4e7, 0, 1)
page4.pack_start(p4e8, 0, 1)
box_newdl.pack_start(btns_newdl, 0, 0)
btns_newdl.pack_start(btn_new_save, 0, 1)
btns_newdl.pack_start(btn_new_open, 0, 1)
btns_newdl.pack_start(btn_new_queue, 0, 1)
btns_newdl.pack_start(btn_new_no, 0, 1)

for label in p1l1, p2l1, p1l2a, p1l2b, p3l1, p4l1a, p4l1b:
	label.set_alignment(0, 0)
	label.set_padding(4, 5)



win_newdl.show_all()
win_newdl.hide()
win_main.show_all()
dbus_service = GwgetService(win_main)
gtk.main()
